/* Generated by Nimrod Compiler v0.9.3 */
/*   (c) 2012 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: MacOSX, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w -O3 -fno-strict-aliasing  -I/usr/src/extras/Nimrod/lib -o compiler/nimcache/memfiles.o compiler/nimcache/memfiles.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <fcntl.h>

#include <unistd.h>

#include <sys/types.h>

#include <sys/stat.h>

#include <sys/time.h>

#include <sys/mman.h>
typedef struct tmemfile211204 tmemfile211204;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
struct tmemfile211204 {
void* Mem;
NI Size;
int Handle;
};
typedef N_NIMCALL_PTR(void, TY891) (void* p, NI op);
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY891 marker;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct TGenericSeq {
NI len;
NI reserved;
};
typedef NIM_CHAR TY611[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY611 data;
};
N_NIMCALL(void, oserror_92005)(NI32 errorcode);
N_NIMCALL(NI32, oslasterror_92052)(void);
TNimType NTI211204; /* TMemFile */
extern TNimType NTI147; /* pointer */
extern TNimType NTI105; /* int */
extern TNimType NTI3701; /* cint */

N_NIMCALL(tmemfile211204, open_211210)(NimStringDesc* filename, NU8 mode, NI mappedsize, NI offset, NI newfilesize) {
	tmemfile211204 result;
	NIM_BOOL readonly;
	int flags;
	int LOC52;
	int LOC58;
	memset((void*)&result, 0, sizeof(result));
	readonly = (mode == ((NU8) 0));
	{
		if (!readonly) goto LA3;
		flags = O_RDONLY;
	}
	goto LA1;
	LA3: ;
	{
		flags = O_RDWR;
	}
	LA1: ;
	{
		if (!!((newfilesize == -1))) goto LA8;
		flags = (NI32)((NI32)(flags | O_CREAT) | O_TRUNC);
	}
	LA8: ;
	result.Handle = open(filename->data, flags);
	{
		NI32 LOC19;
		if (!(result.Handle == ((NI32) -1))) goto LA12;
		result.Mem = NIM_NIL;
		result.Size = 0;
		{
			int LOC18;
			if (!!((result.Handle == ((NI32) 0)))) goto LA16;
			LOC18 = close(result.Handle);
		}
		LA16: ;
		LOC19 = oslasterror_92052();
		oserror_92005(LOC19);
	}
	LA12: ;
	{
		if (!!((newfilesize == -1))) goto LA22;
		{
			int LOC26;
			NI32 LOC34;
			LOC26 = ftruncate(result.Handle, ((off_t) (newfilesize)));
			if (!(LOC26 == ((NI32) -1))) goto LA27;
			result.Mem = NIM_NIL;
			result.Size = 0;
			{
				int LOC33;
				if (!!((result.Handle == ((NI32) 0)))) goto LA31;
				LOC33 = close(result.Handle);
			}
			LA31: ;
			LOC34 = oslasterror_92052();
			oserror_92005(LOC34);
		}
		LA27: ;
	}
	LA22: ;
	{
		if (!!((mappedsize == -1))) goto LA37;
		result.Size = mappedsize;
	}
	goto LA35;
	LA37: ;
	{
		struct stat stat;
		memset((void*)&stat, 0, sizeof(stat));
		{
			int LOC42;
			LOC42 = fstat(result.Handle, &stat);
			if (!!((LOC42 == ((NI32) -1)))) goto LA43;
			result.Size = ((NI) (stat.st_size));
		}
		goto LA40;
		LA43: ;
		{
			NI32 LOC51;
			result.Mem = NIM_NIL;
			result.Size = 0;
			{
				int LOC50;
				if (!!((result.Handle == ((NI32) 0)))) goto LA48;
				LOC50 = close(result.Handle);
			}
			LA48: ;
			LOC51 = oslasterror_92052();
			oserror_92005(LOC51);
		}
		LA40: ;
	}
	LA35: ;
	{
		if (!readonly) goto LA55;
		LOC52 = PROT_READ;
	}
	goto LA53;
	LA55: ;
	{
		LOC52 = (NI32)(PROT_READ | PROT_WRITE);
	}
	LA53: ;
	{
		if (!readonly) goto LA61;
		LOC58 = MAP_PRIVATE;
	}
	goto LA59;
	LA61: ;
	{
		LOC58 = MAP_SHARED;
	}
	LA59: ;
	result.Mem = mmap(NIM_NIL, result.Size, LOC52, LOC58, result.Handle, ((off_t) (offset)));
	{
		NI32 LOC73;
		if (!(result.Mem == ((void*) (MAP_FAILED)))) goto LA66;
		result.Mem = NIM_NIL;
		result.Size = 0;
		{
			int LOC72;
			if (!!((result.Handle == ((NI32) 0)))) goto LA70;
			LOC72 = close(result.Handle);
		}
		LA70: ;
		LOC73 = oslasterror_92052();
		oserror_92005(LOC73);
	}
	LA66: ;
	return result;
}

N_NIMCALL(void, close_211614)(tmemfile211204* f) {
	NIM_BOOL error;
	NI32 lasterr;
	error = NIM_FALSE;
	lasterr = 0;
	{
		int LOC5;
		NIM_BOOL LOC6;
		int LOC7;
		if (!!(((*f).Handle == ((NI32) 0)))) goto LA3;
		lasterr = oslasterror_92052();
		LOC5 = munmap((*f).Mem, (*f).Size);
		error = !((LOC5 == ((NI32) 0)));
		LOC7 = close((*f).Handle);
		LOC6 = !((LOC7 == ((NI32) 0)));
		if (LOC6) goto LA8;
		LOC6 = error;
		LA8: ;
		error = LOC6;
	}
	LA3: ;
	(*f).Size = 0;
	(*f).Mem = NIM_NIL;
	(*f).Handle = ((int) 0);
	{
		if (!error) goto LA11;
		oserror_92005(lasterr);
	}
	LA11: ;
}
N_NOINLINE(void, memfilesInit)(void) {
}

N_NOINLINE(void, memfilesDatInit)(void) {
static TNimNode* TMP802[3];
static TNimNode TMP786[4];
NTI211204.size = sizeof(tmemfile211204);
NTI211204.kind = 18;
NTI211204.base = 0;
NTI211204.flags = 3;
TMP802[0] = &TMP786[1];
TMP786[1].kind = 1;
TMP786[1].offset = offsetof(tmemfile211204, Mem);
TMP786[1].typ = (&NTI147);
TMP786[1].name = "mem";
TMP802[1] = &TMP786[2];
TMP786[2].kind = 1;
TMP786[2].offset = offsetof(tmemfile211204, Size);
TMP786[2].typ = (&NTI105);
TMP786[2].name = "size";
TMP802[2] = &TMP786[3];
TMP786[3].kind = 1;
TMP786[3].offset = offsetof(tmemfile211204, Handle);
TMP786[3].typ = (&NTI3701);
TMP786[3].name = "handle";
TMP786[0].len = 3; TMP786[0].kind = 2; TMP786[0].sons = &TMP802[0];
NTI211204.node = &TMP786[0];
}

