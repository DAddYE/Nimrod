/* Generated by Nimrod Compiler v0.9.3 */
/*   (c) 2012 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: MacOSX, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w -O3 -fno-strict-aliasing  -I/usr/src/extras/Nimrod/lib -o compiler/nimcache/options.o compiler/nimcache/options.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <setjmp.h>

#include <stdio.h>

#include <stdlib.h>
typedef struct tlinkedlist100017 tlinkedlist100017;
typedef struct tlistentry100011 tlistentry100011;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct tcell38449 tcell38449;
typedef struct TNimType TNimType;
typedef struct tcellseq38465 tcellseq38465;
typedef struct tgcheap40416 tgcheap40416;
typedef struct tcellset38461 tcellset38461;
typedef struct tpagedesc38457 tpagedesc38457;
typedef struct tmemregion22010 tmemregion22010;
typedef struct tsmallchunk21243 tsmallchunk21243;
typedef struct tllchunk22004 tllchunk22004;
typedef struct tbigchunk21245 tbigchunk21245;
typedef struct tintset21218 tintset21218;
typedef struct ttrunk21214 ttrunk21214;
typedef struct tavlnode22008 tavlnode22008;
typedef struct tgcstat40414 tgcstat40414;
typedef struct tstringtable103609 tstringtable103609;
typedef struct TY95234 TY95234;
typedef struct TNimNode TNimNode;
typedef struct tkeyvaluepair103605 tkeyvaluepair103605;
typedef struct tstrentry100013 tstrentry100013;
typedef struct TNimObject TNimObject;
typedef struct E_Base E_Base;
typedef struct TSafePoint TSafePoint;
typedef struct tbasechunk21241 tbasechunk21241;
typedef struct tfreecell21233 tfreecell21233;
typedef struct tkeyvaluepairseq103607 tkeyvaluepairseq103607;
struct tlinkedlist100017 {
tlistentry100011* Head;
tlistentry100011* Tail;
NI Counter;
};
struct TGenericSeq {
NI len;
NI reserved;
};
typedef NIM_CHAR TY611[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY611 data;
};
struct tcell38449 {
NI Refcount;
TNimType* Typ;
};
struct tcellseq38465 {
NI Len;
NI Cap;
tcell38449** D;
};
struct tcellset38461 {
NI Counter;
NI Max;
tpagedesc38457* Head;
tpagedesc38457** Data;
};
typedef tsmallchunk21243* TY22022[512];
typedef ttrunk21214* ttrunkbuckets21216[256];
struct tintset21218 {
ttrunkbuckets21216 Data;
};
struct tmemregion22010 {
NI Minlargeobj;
NI Maxlargeobj;
TY22022 Freesmallchunks;
tllchunk22004* Llmem;
NI Currmem;
NI Maxmem;
NI Freemem;
NI Lastsize;
tbigchunk21245* Freechunkslist;
tintset21218 Chunkstarts;
tavlnode22008* Root;
tavlnode22008* Deleted;
tavlnode22008* Last;
tavlnode22008* Freeavlnodes;
};
struct tgcstat40414 {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
NI64 Maxpause;
};
struct tgcheap40416 {
void* Stackbottom;
NI Cyclethreshold;
tcellseq38465 Zct;
tcellseq38465 Decstack;
tcellset38461 Cycleroots;
tcellseq38465 Tempstack;
NI Recgclock;
tmemregion22010 Region;
tgcstat40414 Stat;
};
typedef N_NIMCALL_PTR(void, TY891) (void* p, NI op);
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY891 marker;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct tkeyvaluepair103605 {
NimStringDesc* Field0;
NimStringDesc* Field1;
};
struct TNimObject {
TNimType* m_type;
};
struct tlistentry100011 {
  TNimObject Sup;
tlistentry100011* Prev;
tlistentry100011* Next;
};
struct tstrentry100013 {
  tlistentry100011 Sup;
NimStringDesc* Data;
};
typedef NimStringDesc* TY105434[2];
struct E_Base {
  TNimObject Sup;
E_Base* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
typedef struct {
N_NIMCALL_PTR(NIM_BOOL, ClPrc) (E_Base* e, void* ClEnv);
void* ClEnv;
} TY10426;
struct TSafePoint {
TSafePoint* prev;
NI status;
jmp_buf context;
NIM_BOOL hasRaiseAction;
TY10426 raiseAction;
};
typedef NimStringDesc* TY129263[1];
typedef NU8 TY78658[32];
typedef NI TY21221[8];
struct tpagedesc38457 {
tpagedesc38457* Next;
NI Key;
TY21221 Bits;
};
struct tbasechunk21241 {
NI Prevsize;
NI Size;
NIM_BOOL Used;
};
struct tsmallchunk21243 {
  tbasechunk21241 Sup;
tsmallchunk21243* Next;
tsmallchunk21243* Prev;
tfreecell21233* Freelist;
NI Free;
NI Acc;
NF64 Data;
};
struct tllchunk22004 {
NI Size;
NI Acc;
tllchunk22004* Next;
};
struct tbigchunk21245 {
  tbasechunk21241 Sup;
tbigchunk21245* Next;
tbigchunk21245* Prev;
NI Align;
NF64 Data;
};
struct ttrunk21214 {
ttrunk21214* Next;
NI Key;
TY21221 Bits;
};
typedef tavlnode22008* TY22014[2];
struct tavlnode22008 {
TY22014 Link;
NI Key;
NI Upperbound;
NI Level;
};
struct tstringtable103609 {
  TNimObject Sup;
NI Counter;
tkeyvaluepairseq103607* Data;
NU8 Mode;
};
struct tfreecell21233 {
tfreecell21233* Next;
NI Zerofield;
};
struct TY95234 {
  TGenericSeq Sup;
  NimStringDesc* data[SEQ_DECL_SIZE];
};
struct tkeyvaluepairseq103607 {
  TGenericSeq Sup;
  tkeyvaluepair103605 data[SEQ_DECL_SIZE];
};
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(tcell38449*, usrtocell_41843)(void* usr);
static N_INLINE(void, rtladdzct_43002)(tcell38449* c);
N_NOINLINE(void, addzct_41815)(tcellseq38465* s, tcell38449* c);
N_NIMCALL(tstringtable103609*, nstnewStringTable)(NU8 mode);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
N_NIMCALL(void*, newSeqRC1)(TNimType* typ, NI len);
N_NIMCALL(void, nossplitPath)(NimStringDesc* path, tkeyvaluepair103605* Result);
N_NIMCALL(NimStringDesc*, nosgetAppDir)(void);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(NimStringDesc*, copyStrLast)(NimStringDesc* s, NI start_63424, NI last);
N_NIMCALL(NimStringDesc*, copyStrLast)(NimStringDesc* s, NI first, NI last);
N_NIMCALL(NimStringDesc*, rawfindfile_105498)(NimStringDesc* f);
N_NIMCALL(NimStringDesc*, nosjoinPath)(NimStringDesc* head, NimStringDesc* tail);
N_NIMCALL(NIM_BOOL, nosexistsFile)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, canonicalizepath_105315)(NimStringDesc* path);
N_NIMCALL(NimStringDesc*, nosexpandFilename)(NimStringDesc* filename);
N_NIMCALL(NimStringDesc*, nsuToLowerStr)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, rawfindfile2_105510)(NimStringDesc* f);
N_NIMCALL(void, bringtofront_100694)(tlinkedlist100017* list, tlistentry100011* entry);
N_NIMCALL(NimStringDesc*, nosjoinPathOpenArray)(NimStringDesc** parts, NI partslen0);
N_NIMCALL(NimStringDesc*, getgeneratedpath_105418)(void);
N_NIMCALL(NimStringDesc*, HEX2F_94062)(NimStringDesc* head, NimStringDesc* tail);
N_NIMCALL(NimStringDesc*, shortendir_105403)(NimStringDesc* dir);
N_NIMCALL(NimStringDesc*, getprefixdir_105310)(void);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(NIM_BOOL, nsuStartsWith)(NimStringDesc* s, NimStringDesc* prefix);
N_NIMCALL(NimStringDesc*, copyStr)(NimStringDesc* s, NI start);
N_NIMCALL(NimStringDesc*, copyStr)(NimStringDesc* s, NI first);
N_NIMCALL(NimStringDesc*, noschangeFileExt)(NimStringDesc* filename, NimStringDesc* ext);
N_NIMCALL(NIM_BOOL, nsthasKey)(tstringtable103609* t, NimStringDesc* key);
N_NIMCALL(NimStringDesc*, nstGet)(tstringtable103609* t, NimStringDesc* key);
static N_INLINE(void, pushSafePoint)(TSafePoint* s);
N_NIMCALL(void, noscreateDir)(NimStringDesc* dir);
static N_INLINE(void, popSafePoint)(void);
N_NIMCALL(NIM_BOOL, isObj)(TNimType* obj, TNimType* subclass);
static N_INLINE(E_Base*, getCurrentException)(void);
static N_INLINE(void, popCurrentException)(void);
N_NIMCALL(void, reraiseException)(void);
N_NIMCALL(void, nstPut)(tstringtable103609* t, NimStringDesc* key, NimStringDesc* val);
N_NIMCALL(NimStringDesc*, canondynlibname_105582)(NimStringDesc* s);
N_NIMCALL(NI, nsuFindCharSet)(NimStringDesc* s, TY78658 chars, NI start);
N_NIMCALL(NI, nsuFindChar)(NimStringDesc* s, NIM_CHAR sub, NI start);
N_NIMCALL(void, libcandidates_105544)(NimStringDesc* s, TY95234** dest);
N_NIMCALL(TGenericSeq*, incrSeq)(TGenericSeq* seq, NI elemsize);
static N_INLINE(void, writeln_105451)(FILE* f, NimStringDesc** x, NI xlen0);
N_NIMCALL(void, write_9062)(FILE* f, NimStringDesc* s);
STRING_LITERAL(TMP27, "", 0);
STRING_LITERAL(TMP1120, "nimcache", 8);
STRING_LITERAL(TMP1220, "cannot create directory: ", 25);
STRING_LITERAL(TMP1299, "lib", 3);
static NIM_CONST TY78658 TMP1300 = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
;
STRING_LITERAL(TMP1301, "true", 4);
STRING_LITERAL(TMP4206, "\012", 1);
NU32 goptions_105106;
NU32 gglobaloptions_105108;
NI8 gexitcode_105109;
NU8 gcmd_105110;
NU8 gselectedgc_105111;
tlinkedlist100017 searchpaths_105112;
tlinkedlist100017 lazypaths_105113;
NimStringDesc* outfile_105114;
extern tgcheap40416 gch_40442;
NimStringDesc* headerfile_105115;
NI gverbosity_105116;
NI gnumberofprocessors_105117;
NIM_BOOL gwholeproject_105118;
NimStringDesc* gevalexpr_105119;
NF glastcmdtime_105120;
NIM_BOOL glistfullpaths_105121;
NIM_BOOL isserving_105122;
NI32 gdirtybufferidx_105123;
NI32 gdirtyoriginalidx_105124;
tstringtable103609* gconfigvars_105188;
tstringtable103609* gdlloverrides_105189;
NimStringDesc* libpath_105190;
NimStringDesc* gprojectname_105191;
NimStringDesc* gprojectpath_105192;
NimStringDesc* gprojectfull_105193;
NI32 gprojectmainidx_105194;
NimStringDesc* optmainmodule_105195;
NimStringDesc* nimcachedir_105196;
NimStringDesc* command_105197;
TY95234* commandargs_105218;
extern TNimType NTI95234; /* seq[string] */
NIM_BOOL gkeepcomments_105219;
TY95234* implicitimports_105240;
TY95234* implicitincludes_105261;
TNimType NTI105008; /* TOption */
TNimType NTI105010; /* TOptions */
extern TSafePoint* exchandler_11828;
extern TNimType NTI1035; /* EOS */
extern E_Base* currexception_11830;

static N_INLINE(tcell38449*, usrtocell_41843)(void* usr) {
	tcell38449* result;
	result = 0;
	result = ((tcell38449*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(tcell38449))))));
	return result;
}

static N_INLINE(void, rtladdzct_43002)(tcell38449* c) {
	addzct_41815(&gch_40442.Zct, c);
}

static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	tcell38449* c;
	c = usrtocell_41843(p);
	{
		(*c).Refcount -= 8;
		if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA3;
		rtladdzct_43002(c);
	}
	LA3: ;
}

static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		tcell38449* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_41843(src);
		(*c).Refcount += 8;
	}
	LA3: ;
	{
		tcell38449* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_41843((*dest));
		{
			(*c).Refcount -= 8;
			if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA11;
			rtladdzct_43002(c);
		}
		LA11: ;
	}
	LA7: ;
	(*dest) = src;
}

N_NIMCALL(NimStringDesc*, getprefixdir_105310)(void) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	tkeyvaluepair103605 LOC2;
	result = 0;
	LOC1 = 0;
	LOC1 = nosgetAppDir();
	memset((void*)&LOC2, 0, sizeof(LOC2));
	nossplitPath(LOC1, &LOC2);
	result = copyString(LOC2.Field0);
	return result;
}

N_NIMCALL(NimStringDesc*, removetrailingdirsep_105410)(NimStringDesc* path) {
	NimStringDesc* result;
	result = 0;
	{
		NIM_BOOL LOC3;
		LOC3 = (0 < path->Sup.len);
		if (!(LOC3)) goto LA4;
		LOC3 = ((NU8)(path->data[(NI64)(path->Sup.len - 1)]) == (NU8)(47));
		LA4: ;
		if (!LOC3) goto LA5;
		result = copyStrLast(path, 0, (NI64)(path->Sup.len - 2));
	}
	goto LA1;
	LA5: ;
	{
		result = copyString(path);
	}
	LA1: ;
	return result;
}

N_NIMCALL(NimStringDesc*, canonicalizepath_105315)(NimStringDesc* path) {
	NimStringDesc* result;
	result = 0;
	result = nosexpandFilename(path);
	return result;
}

N_NIMCALL(NimStringDesc*, rawfindfile_105498)(NimStringDesc* f) {
	NimStringDesc* result;
	NimStringDesc* it_105502;
	tstrentry100013* it_105506;
	result = 0;
	it_105502 = 0;
	it_105506 = ((tstrentry100013*) (searchpaths_105112.Head));
	while (1) {
		if (!!((it_105506 == NIM_NIL))) goto LA1;
		it_105502 = (*it_105506).Data;
		result = nosjoinPath(it_105502, f);
		{
			NIM_BOOL LOC4;
			LOC4 = nosexistsFile(result);
			if (!LOC4) goto LA5;
			result = canonicalizepath_105315(result);
			goto BeforeRet;
		}
		LA5: ;
		it_105506 = ((tstrentry100013*) ((*it_105506).Sup.Next));
	} LA1: ;
	result = copyString(((NimStringDesc*) &TMP27));
	BeforeRet: ;
	return result;
}

N_NIMCALL(NimStringDesc*, rawfindfile2_105510)(NimStringDesc* f) {
	NimStringDesc* result;
	tstrentry100013* it;
	result = 0;
	it = ((tstrentry100013*) (lazypaths_105113.Head));
	while (1) {
		if (!!((it == NIM_NIL))) goto LA1;
		result = nosjoinPath((*it).Data, f);
		{
			NIM_BOOL LOC4;
			LOC4 = nosexistsFile(result);
			if (!LOC4) goto LA5;
			bringtofront_100694(&lazypaths_105113, &it->Sup);
			result = canonicalizepath_105315(result);
			goto BeforeRet;
		}
		LA5: ;
		it = ((tstrentry100013*) ((*it).Sup.Next));
	} LA1: ;
	result = copyString(((NimStringDesc*) &TMP27));
	BeforeRet: ;
	return result;
}

N_NIMCALL(NimStringDesc*, findfile_105532)(NimStringDesc* f) {
	NimStringDesc* result;
	result = 0;
	result = rawfindfile_105498(f);
	{
		NimStringDesc* LOC5;
		if (!(result->Sup.len == 0)) goto LA3;
		LOC5 = 0;
		LOC5 = nsuToLowerStr(f);
		result = rawfindfile_105498(LOC5);
		{
			if (!(result->Sup.len == 0)) goto LA8;
			result = rawfindfile2_105510(f);
			{
				NimStringDesc* LOC14;
				if (!(result->Sup.len == 0)) goto LA12;
				LOC14 = 0;
				LOC14 = nsuToLowerStr(f);
				result = rawfindfile2_105510(LOC14);
			}
			LA12: ;
		}
		LA8: ;
	}
	LA3: ;
	return result;
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));
	(*dest).Sup.len += (*src).Sup.len;
}

static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c) {
	(*dest).data[((*dest).Sup.len)- 0] = c;
	(*dest).data[((NI64)((*dest).Sup.len + 1))- 0] = 0;
	(*dest).Sup.len += 1;
}

N_NIMCALL(NimStringDesc*, shortendir_105403)(NimStringDesc* dir) {
	NimStringDesc* result;
	NimStringDesc* prefix;
	NimStringDesc* LOC1;
	NimStringDesc* LOC2;
	NimStringDesc* LOC8;
	result = 0;
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = getprefixdir_105310();
	LOC1 = rawNewString(LOC2->Sup.len + 1);
appendString(LOC1, LOC2);
appendChar(LOC1, 47);
	prefix = LOC1;
	{
		NIM_BOOL LOC5;
		LOC5 = nsuStartsWith(dir, prefix);
		if (!LOC5) goto LA6;
		result = copyStr(dir, prefix->Sup.len);
		goto BeforeRet;
	}
	LA6: ;
	LOC8 = 0;
	LOC8 = rawNewString(gprojectpath_105192->Sup.len + 1);
appendString(LOC8, gprojectpath_105192);
appendChar(LOC8, 47);
	prefix = LOC8;
	{
		NIM_BOOL LOC11;
		LOC11 = nsuStartsWith(dir, prefix);
		if (!LOC11) goto LA12;
		result = copyStr(dir, prefix->Sup.len);
		goto BeforeRet;
	}
	LA12: ;
	result = copyString(dir);
	BeforeRet: ;
	return result;
}

N_NIMCALL(NimStringDesc*, getgeneratedpath_105418)(void) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(0 < nimcachedir_105196->Sup.len)) goto LA3;
		result = copyString(nimcachedir_105196);
	}
	goto LA1;
	LA3: ;
	{
		NimStringDesc* LOC6;
		LOC6 = 0;
		LOC6 = shortendir_105403(gprojectpath_105192);
		result = HEX2F_94062(LOC6, ((NimStringDesc*) &TMP1120));
	}
	LA1: ;
	return result;
}

N_NIMCALL(NimStringDesc*, togeneratedfile_105425)(NimStringDesc* path, NimStringDesc* ext) {
	NimStringDesc* result;
	tkeyvaluepair103605 LOC1;
	NimStringDesc* head;
	NimStringDesc* tail;
	TY105434 LOC2;
	result = 0;
	memset((void*)&LOC1, 0, sizeof(LOC1));
	nossplitPath(path, &LOC1);
	head = copyString(LOC1.Field0);
	tail = copyString(LOC1.Field1);
	memset((void*)LOC2, 0, sizeof(LOC2));
	LOC2[0] = getgeneratedpath_105418();
	LOC2[1] = noschangeFileExt(tail, ext);
	result = nosjoinPathOpenArray(LOC2, 2);
	return result;
}

N_NIMCALL(NIM_BOOL, existsconfigvar_105285)(NimStringDesc* key) {
	NIM_BOOL result;
	result = 0;
	result = nsthasKey(gconfigvars_105188, key);
	return result;
}

N_NIMCALL(NimStringDesc*, getconfigvar_105291)(NimStringDesc* key) {
	NimStringDesc* result;
	result = 0;
	result = nstGet(gconfigvars_105188, key);
	return result;
}

static N_INLINE(void, pushSafePoint)(TSafePoint* s) {
	(*s).hasRaiseAction = NIM_FALSE;
	(*s).prev = exchandler_11828;
	exchandler_11828 = s;
}

static N_INLINE(void, popSafePoint)(void) {
	exchandler_11828 = (*exchandler_11828).prev;
}

static N_INLINE(E_Base*, getCurrentException)(void) {
	E_Base* result;
	result = 0;
	result = currexception_11830;
	return result;
}

static N_INLINE(void, popCurrentException)(void) {
	asgnRefNoCycle((void**) &currexception_11830, (*currexception_11830).parent);
}

N_NIMCALL(NimStringDesc*, completegeneratedfilepath_105438)(NimStringDesc* f, NIM_BOOL createsubdir) {
	NimStringDesc* result;
	tkeyvaluepair103605 LOC1;
	NimStringDesc* head;
	NimStringDesc* tail;
	NimStringDesc* subdir;
	result = 0;
	memset((void*)&LOC1, 0, sizeof(LOC1));
	nossplitPath(f, &LOC1);
	head = copyString(LOC1.Field0);
	tail = copyString(LOC1.Field1);
	subdir = getgeneratedpath_105418();
	{
		TSafePoint TMP1219;
		if (!createsubdir) goto LA4;
		pushSafePoint(&TMP1219);
		TMP1219.status = setjmp(TMP1219.context);
		if (TMP1219.status == 0) {
			noscreateDir(subdir);
			popSafePoint();
		}
		else {
			popSafePoint();
			if (isObj(getCurrentException()->Sup.m_type, (&NTI1035))) {
				TY129263 LOC9;
				NimStringDesc* LOC10;
				TMP1219.status = 0;
				memset((void*)LOC9, 0, sizeof(LOC9));
				LOC10 = 0;
				LOC10 = rawNewString(subdir->Sup.len + 25);
appendString(LOC10, ((NimStringDesc*) &TMP1220));
appendString(LOC10, subdir);
				LOC9[0] = LOC10;
				writeln_105451(stdout, LOC9, 1);
				exit(1);
				popCurrentException();
			}
		}
		if (TMP1219.status != 0) reraiseException();
	}
	LA4: ;
	result = nosjoinPath(subdir, tail);
	return result;
}

N_NIMCALL(NimStringDesc*, canondynlibname_105582)(NimStringDesc* s) {
	NimStringDesc* result;
	NI start;
	NI ende;
	result = 0;
	{
		NIM_BOOL LOC3;
		LOC3 = nsuStartsWith(s, ((NimStringDesc*) &TMP1299));
		if (!LOC3) goto LA4;
		start = 3;
	}
	goto LA1;
	LA4: ;
	{
		start = 0;
	}
	LA1: ;
	ende = nsuFindCharSet(s, TMP1300, 0);
	{
		if (!(0 <= ende)) goto LA9;
		result = copyStrLast(s, start, (NI64)(ende - 1));
	}
	goto LA7;
	LA9: ;
	{
		result = copyStr(s, start);
	}
	LA7: ;
	return result;
}

N_NIMCALL(void, incldynliboverride_105591)(NimStringDesc* lib) {
	NimStringDesc* LOC1;
	LOC1 = 0;
	LOC1 = canondynlibname_105582(lib);
	nstPut(gdlloverrides_105189, LOC1, ((NimStringDesc*) &TMP1301));
}

N_NIMCALL(void, setconfigvar_105297)(NimStringDesc* key, NimStringDesc* val) {
	nstPut(gconfigvars_105188, key, val);
}

N_NIMCALL(NIM_BOOL, isdynliboverride_105596)(NimStringDesc* lib) {
	NIM_BOOL result;
	NimStringDesc* LOC1;
	result = 0;
	LOC1 = 0;
	LOC1 = canondynlibname_105582(lib);
	result = nsthasKey(gdlloverrides_105189, LOC1);
	return result;
}

N_NIMCALL(void, libcandidates_105544)(NimStringDesc* s, TY95234** dest) {
	NI le;
	NI ri;
	le = nsuFindChar(s, 40, 0);
	ri = nsuFindChar(s, 41, (NI64)(le + 1));
	{
		NIM_BOOL LOC3;
		NimStringDesc* prefix;
		NimStringDesc* suffix;
		NimStringDesc* middle_105556;
		NimStringDesc* HEX3Atmp_105573;
		NI last_105575;
		LOC3 = (0 <= le);
		if (!(LOC3)) goto LA4;
		LOC3 = (le < ri);
		LA4: ;
		if (!LOC3) goto LA5;
		prefix = copyStrLast(s, 0, (NI64)(le - 1));
		suffix = copyStr(s, (NI64)(ri + 1));
		middle_105556 = 0;
		HEX3Atmp_105573 = 0;
		HEX3Atmp_105573 = copyStrLast(s, (NI64)(le + 1), (NI64)(ri - 1));
		last_105575 = 0;
		{
			if (!(0 < HEX3Atmp_105573->Sup.len)) goto LA9;
			while (1) {
				NI first_105577;
				NimStringDesc* LOC15;
				if (!(last_105575 <= HEX3Atmp_105573->Sup.len)) goto LA11;
				first_105577 = last_105575;
				while (1) {
					NIM_BOOL LOC13;
					LOC13 = (last_105575 < HEX3Atmp_105573->Sup.len);
					if (!(LOC13)) goto LA14;
					LOC13 = !(((NU8)(HEX3Atmp_105573->data[last_105575]) == (NU8)(124)));
					LA14: ;
					if (!LOC13) goto LA12;
					last_105575 += 1;
				} LA12: ;
				middle_105556 = copyStrLast(HEX3Atmp_105573, first_105577, (NI64)(last_105575 - 1));
				LOC15 = 0;
				LOC15 = rawNewString(prefix->Sup.len + middle_105556->Sup.len + suffix->Sup.len + 0);
appendString(LOC15, prefix);
appendString(LOC15, middle_105556);
appendString(LOC15, suffix);
				libcandidates_105544(LOC15, dest);
				last_105575 += 1;
			} LA11: ;
		}
		LA9: ;
	}
	goto LA1;
	LA5: ;
	{
		NimStringDesc* LOC17;
		(*dest) = (TY95234*) incrSeq(&((*dest))->Sup, sizeof(NimStringDesc*));
		LOC17 = 0;
		LOC17 = (*dest)->data[(*dest)->Sup.len-1]; (*dest)->data[(*dest)->Sup.len-1] = copyStringRC1(s);
		if (LOC17) nimGCunrefNoCycle(LOC17);
	}
	LA1: ;
}

N_NIMCALL(NimStringDesc*, maincommandarg_105270)(void) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(0 < commandargs_105218->Sup.len)) goto LA3;
		result = copyString(commandargs_105218->data[0]);
	}
	goto LA1;
	LA3: ;
	{
		result = copyString(gprojectname_105191);
	}
	LA1: ;
	return result;
}

N_NIMCALL(NimStringDesc*, getoutfile_105303)(NimStringDesc* filename, NimStringDesc* ext) {
	NimStringDesc* result;
	result = 0;
	{
		if (!!(((outfile_105114) && (outfile_105114)->Sup.len == 0))) goto LA3;
		result = copyString(outfile_105114);
	}
	goto LA1;
	LA3: ;
	{
		result = noschangeFileExt(filename, ext);
	}
	LA1: ;
	return result;
}

static N_INLINE(void, writeln_105451)(FILE* f, NimStringDesc** x, NI xlen0) {
	NimStringDesc* i_105465;
	NI i_105471;
	i_105465 = 0;
	i_105471 = 0;
	while (1) {
		if (!(i_105471 < xlen0)) goto LA1;
		i_105465 = x[i_105471];
		write_9062(f, i_105465);
		i_105471 += 1;
	} LA1: ;
	write_9062(f, ((NimStringDesc*) &TMP4206));
}
N_NOINLINE(void, optionsInit)(void) {
	NimStringDesc* LOC1;
	NimStringDesc* LOC2;
	NimStringDesc* LOC3;
	NimStringDesc* LOC4;
	NimStringDesc* LOC5;
	NimStringDesc* LOC6;
	NimStringDesc* LOC7;
	NimStringDesc* LOC8;
	NimStringDesc* LOC9;
	NimStringDesc* LOC10;
	goptions_105106 = 2202238;
	gglobaloptions_105108 = 134217728;
	gcmd_105110 = ((NU8) 0);
	gselectedgc_105111 = ((NU8) 3);
	LOC1 = 0;
	LOC1 = outfile_105114; outfile_105114 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC1) nimGCunrefNoCycle(LOC1);
	LOC2 = 0;
	LOC2 = headerfile_105115; headerfile_105115 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC2) nimGCunrefNoCycle(LOC2);
	gverbosity_105116 = 1;
	LOC3 = 0;
	LOC3 = gevalexpr_105119; gevalexpr_105119 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC3) nimGCunrefNoCycle(LOC3);
	isserving_105122 = NIM_FALSE;
	gdirtybufferidx_105123 = ((NI32) 0);
	gdirtyoriginalidx_105124 = ((NI32) 0);
	asgnRefNoCycle((void**) &gconfigvars_105188, nstnewStringTable(((NU8) 2)));
	asgnRefNoCycle((void**) &gdlloverrides_105189, nstnewStringTable(((NU8) 1)));
	LOC4 = 0;
	LOC4 = libpath_105190; libpath_105190 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC4) nimGCunrefNoCycle(LOC4);
	LOC5 = 0;
	LOC5 = gprojectname_105191; gprojectname_105191 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC5) nimGCunrefNoCycle(LOC5);
	LOC6 = 0;
	LOC6 = gprojectpath_105192; gprojectpath_105192 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC6) nimGCunrefNoCycle(LOC6);
	LOC7 = 0;
	LOC7 = gprojectfull_105193; gprojectfull_105193 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC7) nimGCunrefNoCycle(LOC7);
	LOC8 = 0;
	LOC8 = optmainmodule_105195; optmainmodule_105195 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC8) nimGCunrefNoCycle(LOC8);
	LOC9 = 0;
	LOC9 = nimcachedir_105196; nimcachedir_105196 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC9) nimGCunrefNoCycle(LOC9);
	LOC10 = 0;
	LOC10 = command_105197; command_105197 = copyStringRC1(((NimStringDesc*) &TMP27));
	if (LOC10) nimGCunrefNoCycle(LOC10);
	if (commandargs_105218) nimGCunrefNoCycle(commandargs_105218);
	commandargs_105218 = (TY95234*) newSeqRC1((&NTI95234), 0);
	gkeepcomments_105219 = NIM_TRUE;
	if (implicitimports_105240) nimGCunrefNoCycle(implicitimports_105240);
	implicitimports_105240 = (TY95234*) newSeqRC1((&NTI95234), 0);
	if (implicitincludes_105261) nimGCunrefNoCycle(implicitincludes_105261);
	implicitincludes_105261 = (TY95234*) newSeqRC1((&NTI95234), 0);
}

N_NOINLINE(void, optionsDatInit)(void) {
static TNimNode* TMP450[22];
NI TMP452;
static char* NIM_CONST TMP451[22] = {
"optNone", 
"optObjCheck", 
"optFieldCheck", 
"optRangeCheck", 
"optBoundsCheck", 
"optOverflowCheck", 
"optNilCheck", 
"optNaNCheck", 
"optInfCheck", 
"optAssert", 
"optLineDir", 
"optWarns", 
"optHints", 
"optOptimizeSpeed", 
"optOptimizeSize", 
"optStackTrace", 
"optLineTrace", 
"optEndb", 
"optByRef", 
"optProfiler", 
"optImplicitStatic", 
"optPatterns"};
static TNimNode TMP19[24];
NTI105008.size = sizeof(NU8);
NTI105008.kind = 14;
NTI105008.base = 0;
NTI105008.flags = 3;
for (TMP452 = 0; TMP452 < 22; TMP452++) {
TMP19[TMP452+0].kind = 1;
TMP19[TMP452+0].offset = TMP452;
TMP19[TMP452+0].name = TMP451[TMP452];
TMP450[TMP452] = &TMP19[TMP452+0];
}
TMP19[22].len = 22; TMP19[22].kind = 2; TMP19[22].sons = &TMP450[0];
NTI105008.node = &TMP19[22];
NTI105010.size = sizeof(NU32);
NTI105010.kind = 19;
NTI105010.base = (&NTI105008);
NTI105010.flags = 3;
TMP19[23].len = 0; TMP19[23].kind = 0;
NTI105010.node = &TMP19[23];
}

