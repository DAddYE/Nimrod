/* Generated by Nimrod Compiler v0.9.3 */
/*   (c) 2012 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: MacOSX, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w -O3 -fno-strict-aliasing  -I/usr/src/extras/Nimrod/lib -o compiler/nimcache/msgs.o compiler/nimcache/msgs.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>

#include <stdio.h>

#include <stdlib.h>

#include <setjmp.h>
typedef struct ttable128335 ttable128335;
typedef struct tkeyvaluepairseq128340 tkeyvaluepairseq128340;
typedef struct tkeyvaluepair128345 tkeyvaluepair128345;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TY128415 TY128415;
typedef struct tfileinfo128306 tfileinfo128306;
typedef struct trope126007 trope126007;
typedef struct TY128316 TY128316;
typedef struct tcell38449 tcell38449;
typedef struct tcellseq38465 tcellseq38465;
typedef struct tgcheap40416 tgcheap40416;
typedef struct tcellset38461 tcellset38461;
typedef struct tpagedesc38457 tpagedesc38457;
typedef struct tmemregion22010 tmemregion22010;
typedef struct tsmallchunk21243 tsmallchunk21243;
typedef struct tllchunk22004 tllchunk22004;
typedef struct tbigchunk21245 tbigchunk21245;
typedef struct tintset21218 tintset21218;
typedef struct ttrunk21214 ttrunk21214;
typedef struct tavlnode22008 tavlnode22008;
typedef struct tgcstat40414 tgcstat40414;
typedef struct tlineinfo128308 tlineinfo128308;
typedef struct tsocketimpl110806 tsocketimpl110806;
typedef struct TY128959 TY128959;
typedef struct erecoverableerror128310 erecoverableerror128310;
typedef struct einvalidvalue1053 einvalidvalue1053;
typedef struct esynch1029 esynch1029;
typedef struct E_Base E_Base;
typedef struct TNimObject TNimObject;
typedef struct tslice129620 tslice129620;
typedef struct TSafePoint TSafePoint;
typedef struct TY71082 TY71082;
typedef struct esuggestdone128312 esuggestdone128312;
typedef struct tbasechunk21241 tbasechunk21241;
typedef struct tfreecell21233 tfreecell21233;
struct TGenericSeq {
NI len;
NI reserved;
};
typedef NIM_CHAR TY611[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY611 data;
};
struct tkeyvaluepair128345 {
NU8 Field0;
NimStringDesc* Field1;
NI32 Field2;
};
struct ttable128335 {
tkeyvaluepairseq128340* Data;
NI Counter;
};
typedef N_NIMCALL_PTR(void, TY891) (void* p, NI op);
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY891 marker;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct tfileinfo128306 {
NimStringDesc* Fullpath;
NimStringDesc* Projpath;
trope126007* Quotedname;
TY128316* Lines;
};
struct tcell38449 {
NI Refcount;
TNimType* Typ;
};
struct tcellseq38465 {
NI Len;
NI Cap;
tcell38449** D;
};
struct tcellset38461 {
NI Counter;
NI Max;
tpagedesc38457* Head;
tpagedesc38457** Data;
};
typedef tsmallchunk21243* TY22022[512];
typedef ttrunk21214* ttrunkbuckets21216[256];
struct tintset21218 {
ttrunkbuckets21216 Data;
};
struct tmemregion22010 {
NI Minlargeobj;
NI Maxlargeobj;
TY22022 Freesmallchunks;
tllchunk22004* Llmem;
NI Currmem;
NI Maxmem;
NI Freemem;
NI Lastsize;
tbigchunk21245* Freechunkslist;
tintset21218 Chunkstarts;
tavlnode22008* Root;
tavlnode22008* Deleted;
tavlnode22008* Last;
tavlnode22008* Freeavlnodes;
};
struct tgcstat40414 {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
NI64 Maxpause;
};
struct tgcheap40416 {
void* Stackbottom;
NI Cyclethreshold;
tcellseq38465 Zct;
tcellseq38465 Decstack;
tcellset38461 Cycleroots;
tcellseq38465 Tempstack;
NI Recgclock;
tmemregion22010 Region;
tgcstat40414 Stat;
};
struct tlineinfo128308 {
NI16 Line;
NI16 Col;
NI32 Fileindex;
};
typedef struct {
N_NIMCALL_PTR(void, ClPrc) (NU8 err, NimStringDesc* msg, NIM_BOOL usewarning, void* ClEnv);
void* ClEnv;
} TY126103;
typedef NimStringDesc* TY129263[1];
typedef NimStringDesc* TY129439[4];
typedef NimStringDesc* TY128266[260];
struct TNimObject {
TNimType* m_type;
};
struct E_Base {
  TNimObject Sup;
E_Base* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
struct esynch1029 {
  E_Base Sup;
};
struct einvalidvalue1053 {
  esynch1029 Sup;
};
struct erecoverableerror128310 {
  einvalidvalue1053 Sup;
};
typedef N_CLOSURE_PTR(void, TMP402) (NU8 err, NimStringDesc* msg, NIM_BOOL usewarning, void* ClEnv);
struct tslice129620 {
NU16 A;
NU16 B;
};
typedef struct {
N_NIMCALL_PTR(NIM_BOOL, ClPrc) (E_Base* e, void* ClEnv);
void* ClEnv;
} TY10426;
struct TSafePoint {
TSafePoint* prev;
NI status;
jmp_buf context;
NIM_BOOL hasRaiseAction;
TY10426 raiseAction;
};
struct TY71082 {
NimStringDesc* Field0;
NI Field1;
};
struct esuggestdone128312 {
  E_Base Sup;
};
struct trope126007 {
  TNimObject Sup;
trope126007* Left;
trope126007* Right;
NI Length;
NimStringDesc* Data;
};
typedef NI TY21221[8];
struct tpagedesc38457 {
tpagedesc38457* Next;
NI Key;
TY21221 Bits;
};
struct tbasechunk21241 {
NI Prevsize;
NI Size;
NIM_BOOL Used;
};
struct tsmallchunk21243 {
  tbasechunk21241 Sup;
tsmallchunk21243* Next;
tsmallchunk21243* Prev;
tfreecell21233* Freelist;
NI Free;
NI Acc;
NF64 Data;
};
struct tllchunk22004 {
NI Size;
NI Acc;
tllchunk22004* Next;
};
struct tbigchunk21245 {
  tbasechunk21241 Sup;
tbigchunk21245* Next;
tbigchunk21245* Prev;
NI Align;
NF64 Data;
};
struct ttrunk21214 {
ttrunk21214* Next;
NI Key;
TY21221 Bits;
};
typedef tavlnode22008* TY22014[2];
struct tavlnode22008 {
TY22014 Link;
NI Key;
NI Upperbound;
NI Level;
};
typedef NIM_CHAR TY110829[4001];
struct tsocketimpl110806 {
int Fd;
NIM_BOOL Isbuffered;
union {
struct {TY110829 Buffer;
NI Currpos;
NI Buflen;
} S1;
} isbufferedU;
NIM_BOOL Nonblocking;
};
struct tfreecell21233 {
tfreecell21233* Next;
NI Zerofield;
};
struct tkeyvaluepairseq128340 {
  TGenericSeq Sup;
  tkeyvaluepair128345 data[SEQ_DECL_SIZE];
};
struct TY128316 {
  TGenericSeq Sup;
  trope126007* data[SEQ_DECL_SIZE];
};
struct TY128415 {
  TGenericSeq Sup;
  tfileinfo128306 data[SEQ_DECL_SIZE];
};
struct TY128959 {
  TGenericSeq Sup;
  tlineinfo128308 data[SEQ_DECL_SIZE];
};
N_NOINLINE(void, chckNil)(void* p);
N_NIMCALL(void, genericReset)(void* dest, TNimType* mt);
N_NIMCALL(void, nimGCvisit)(void* d, NI op);
N_NIMCALL(void, TMP127)(void* p, NI op);
N_NIMCALL(void, TMP128)(void* p, NI op);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(tcell38449*, usrtocell_41843)(void* usr);
static N_INLINE(void, rtladdzct_43002)(tcell38449* c);
N_NOINLINE(void, addzct_41815)(tcellseq38465* s, tcell38449* c);
N_NIMCALL(void*, newSeqRC1)(TNimType* typ, NI len);
N_NIMCALL(void, newfileinfo_128471)(NimStringDesc* fullpath, NimStringDesc* projpath, tfileinfo128306* Result);
N_NIMCALL(void, unsureAsgnRef)(void** dest, void* src);
N_NIMCALL(NimStringDesc*, copyString)(NimStringDesc* src);
N_NIMCALL(trope126007*, makecstring_128446)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, addChar)(NimStringDesc* s, NIM_CHAR c);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, resizeString)(NimStringDesc* dest, NI addlen);
N_NIMCALL(void, app_126040)(trope126007** a, trope126007* b);
N_NIMCALL(trope126007*, torope_126058)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, setLengthStr)(NimStringDesc* s, NI newlen);
N_NIMCALL(NimStringDesc*, tocchar_128440)(NIM_CHAR c);
static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c);
N_NIMCALL(NimStringDesc*, nsuToOctal)(NIM_CHAR c);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
N_NIMCALL(NimStringDesc*, nimCharToStr)(NIM_CHAR x);
N_NIMCALL(NimStringDesc*, nosextractFilename)(NimStringDesc* path);
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(TGenericSeq*, incrSeq)(TGenericSeq* seq, NI elemsize);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
N_NIMCALL(void, genericSeqAssign)(void* dest, void* src_67004, TNimType* mt);
N_NIMCALL(tlineinfo128308, newlineinfo_128768)(NI32 fileinfoidx, NI line, NI col);
N_NIMCALL(void, TMP135)(void* p, NI op);
N_NIMCALL(tlineinfo128308, unknownlineinfo_128954)(void);
N_NIMCALL(void, HEX3Aanonymous_129824)(NU8 err, NimStringDesc* msg, NIM_BOOL usewarning);
N_NIMCALL(void, internalerror_129699)(NimStringDesc* errmsg);
N_NIMCALL(void, writecontext_129416)(tlineinfo128308 lastinfo);
N_NIMCALL(NIM_BOOL, HEX3DHEX3D_129409)(tlineinfo128308 a, tlineinfo128308 b);
N_NIMCALL(void, msgwriteln_129225)(NimStringDesc* s);
N_NIMCALL(NimStringDesc*, nsuFormatOpenArray)(NimStringDesc* formatstr, NimStringDesc** a, NI alen0);
N_NIMCALL(NimStringDesc*, tomsgfilename_129113)(tlineinfo128308 info);
N_NIMCALL(NimStringDesc*, coordtostr_129280)(NI coord);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI x);
N_NIMCALL(NimStringDesc*, getmessagestr_129292)(NU16 msg, NimStringDesc* arg);
N_NIMCALL(NimStringDesc*, msgkindtostring_129286)(NU16 kind);
N_NIMCALL(void, rawmessage_129518)(NU16 msg, NimStringDesc* arg);
N_NIMCALL(void, rawmessage_129448)(NU16 msg, NimStringDesc** args, NI argslen0);
N_NIMCALL(NimStringDesc*, nsuFormatSingleElem)(NimStringDesc* formatstr, NimStringDesc* a);
N_NIMCALL(void, handleerror_129339)(NU16 msg, NU8 eh, NimStringDesc* s);
N_NIMCALL(void, writestacktrace_11206)(void);
N_NOINLINE(void, raiserecoverableerror_128822)(NimStringDesc* msg);
N_NIMCALL(void, TMP399)(void* p, NI op);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
N_NIMCALL(void, raiseException)(E_Base* e, NCSTRING ename);
static N_INLINE(void, asgnRef)(void** dest, void* src);
static N_INLINE(void, incref_43824)(tcell38449* c);
static N_INLINE(NIM_BOOL, canbecycleroot_41865)(tcell38449* c);
static N_INLINE(void, rtladdcycleroot_42436)(tcell38449* c);
N_NOINLINE(void, incl_39256)(tcellset38461* s, tcell38449* cell);
static N_INLINE(void, decref_43402)(tcell38449* c);
N_NIMCALL(void, limessage_129536)(tlineinfo128308 info, NU16 msg, NimStringDesc* arg, NU8 eh);
N_NIMCALL(void, writesurroundingsrc_129530)(tlineinfo128308 info);
N_NIMCALL(NimStringDesc*, ropetostr_126075)(trope126007* p);
N_NIMCALL(trope126007*, sourceline_128847)(tlineinfo128308 i);
static N_INLINE(void, pushSafePoint)(TSafePoint* s);
N_NIMCALL(NimStringDesc*, tofullpath_129095)(NI32 fileidx);
N_NIMCALL(FILE*, open_8832)(NimStringDesc* filename, NU8 mode, NI bufsize);
N_NIMCALL(NimStringDesc*, rawNewString)(NI cap);
N_NIMCALL(NIM_BOOL, readline_9086)(FILE* f, NimStringDesc** line);
N_NIMCALL(void, addsourceline_129718)(NI32 fileidx, NimStringDesc* line);
static N_INLINE(void, popSafePoint)(void);
N_NIMCALL(NIM_BOOL, isObj)(TNimType* obj, TNimType* subclass);
static N_INLINE(E_Base*, getCurrentException)(void);
static N_INLINE(void, popCurrentException)(void);
N_NIMCALL(void, reraiseException)(void);
N_NIMCALL(NimStringDesc*, nsuRepeatChar)(NI count, NIM_CHAR c);
N_NIMCALL(NimStringDesc*, canonicalizepath_105315)(NimStringDesc* path);
static N_INLINE(void, shallow_71620)(NimStringDesc** s_71623);
N_NIMCALL(NimStringDesc*, shortendir_105403)(NimStringDesc* dir);
N_NIMCALL(void, send_120404)(tsocketimpl110806* socket, NimStringDesc* data);
N_NIMCALL(TGenericSeq*, setLengthSeq)(TGenericSeq* seq, NI elemsize, NI newlen);
N_NIMCALL(void, TMP2429)(void* p, NI op);
N_NIMCALL(void, inittable_128325)(NI initialsize, ttable128335* Result);
static N_INLINE(void, writeln_105451)(FILE* f, NimStringDesc** x, NI xlen0);
N_NIMCALL(void, write_9062)(FILE* f, NimStringDesc* s);
static N_INLINE(NIM_BOOL, contains_129630)(tslice129620 s, NU16 value);
static N_INLINE(tslice129620, HEX2EHEX2E_129610)(NU16 a, NU16 b);
N_NIMCALL(NimStringDesc*, HEX24_129777)(TY71082 x);
N_NIMCALL(NIM_BOOL, haskey_128516)(ttable128335 t, NimStringDesc* key);
N_NIMCALL(NI32, HEX5BHEX5D_128555)(ttable128335 t, NimStringDesc* key);
N_NIMCALL(void, HEX5BHEX5DHEX3D_128604)(ttable128335* t, NimStringDesc* key, NI32 val);
static N_INLINE(NIM_BOOL, mustrehash_108283)(NI length, NI counter);
N_NIMCALL(NI, rawget_128527)(ttable128335 t, NimStringDesc* key);
N_NIMCALL(NI, hash_101825)(NimStringDesc* x);
static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b);
static N_INLINE(NI, nexttry_108407)(NI h, NI maxhash);
N_NIMCALL(void, enlarge_128637)(ttable128335* t);
N_NIMCALL(void, rawinsert_128690)(ttable128335* t, tkeyvaluepairseq128340** data, NimStringDesc* key, NI32 val);
STRING_LITERAL(TMP129, "\"", 1);
STRING_LITERAL(TMP131, "", 0);
STRING_LITERAL(TMP132, "command line", 12);
STRING_LITERAL(TMP133, "compilation artifact", 20);
STRING_LITERAL(TMP137, "$1($2, $3) Info: $4", 19);
STRING_LITERAL(TMP138, "???", 3);
STRING_LITERAL(TMP139, "unknown error", 13);
STRING_LITERAL(TMP140, "illformed AST: $1", 17);
STRING_LITERAL(TMP141, "internal error: $1", 18);
STRING_LITERAL(TMP142, "cannot open \'$1\'", 16);
STRING_LITERAL(TMP143, "$1", 2);
STRING_LITERAL(TMP144, "\'$1\' compiler does not support C++", 34);
STRING_LITERAL(TMP145, "string literal expected", 23);
STRING_LITERAL(TMP146, "integer literal expected", 24);
STRING_LITERAL(TMP147, "invalid character constant", 26);
STRING_LITERAL(TMP148, "closing \"\"\" expected, but end of file reached", 45);
STRING_LITERAL(TMP149, "closing \" expected", 18);
STRING_LITERAL(TMP150, "tabulators are not allowed", 26);
STRING_LITERAL(TMP151, "invalid token: $1", 17);
STRING_LITERAL(TMP152, "line too long", 13);
STRING_LITERAL(TMP153, "$1 is not a valid number", 24);
STRING_LITERAL(TMP154, "number $1 out of valid range", 28);
STRING_LITERAL(TMP155, "\\n not allowed in character literal", 35);
STRING_LITERAL(TMP156, "closing \']\' expected, but end of file reached", 45);
STRING_LITERAL(TMP157, "missing final \' for character literal", 37);
STRING_LITERAL(TMP158, "identifier expected, but found \'$1\'", 35);
STRING_LITERAL(TMP159, "newline expected, but found \'$1\'", 32);
STRING_LITERAL(TMP160, "invalid module name: \'$1\'", 25);
STRING_LITERAL(TMP161, "operator expected, but found \'$1\'", 33);
STRING_LITERAL(TMP162, "\'$1\' expected", 13);
STRING_LITERAL(TMP163, "string after \'include\' expected", 31);
STRING_LITERAL(TMP164, "recursive dependency: \'$1\'", 26);
STRING_LITERAL(TMP165, "\'on\' or \'off\' expected", 22);
STRING_LITERAL(TMP166, "\'none\', \'speed\' or \'size\' expected", 34);
STRING_LITERAL(TMP167, "invalid pragma", 14);
STRING_LITERAL(TMP168, "unknown pragma: \'$1\'", 20);
STRING_LITERAL(TMP169, "invalid directive: \'$1\'", 23);
STRING_LITERAL(TMP170, "\'pop\' without a \'push\' pragma", 29);
STRING_LITERAL(TMP171, "empty asm statement", 19);
STRING_LITERAL(TMP172, "invalid indentation", 19);
STRING_LITERAL(TMP173, "exception expected", 18);
STRING_LITERAL(TMP174, "exception already handled", 25);
STRING_LITERAL(TMP175, "\'yield\' only allowed in an iterator", 35);
STRING_LITERAL(TMP176, "\'yield\' cannot be used within \'try\' in a non-inlined iterator", 61);
STRING_LITERAL(TMP177, "invalid number of \'yield\' expressions", 37);
STRING_LITERAL(TMP178, "current routine cannot return an expression", 43);
STRING_LITERAL(TMP179, "redefinition of \'$1\'", 20);
STRING_LITERAL(TMP180, "statement not allowed after \'return\', \'break\' or \'raise\'", 56);
STRING_LITERAL(TMP181, "statement expected", 18);
STRING_LITERAL(TMP182, "\'$1\' is no label", 16);
STRING_LITERAL(TMP183, "invalid command line option: \'$1\'", 33);
STRING_LITERAL(TMP184, "argument for command line option expected: \'$1\'", 47);
STRING_LITERAL(TMP185, "invalid argument for command line option: \'$1\'", 46);
STRING_LITERAL(TMP186, "invalid variable substitution in \'$1\'", 37);
STRING_LITERAL(TMP187, "unknown variable: \'$1\'", 22);
STRING_LITERAL(TMP188, "unknown C compiler: \'$1\'", 24);
STRING_LITERAL(TMP189, "\'on\' or \'off\' expected, but \'$1\' found", 38);
STRING_LITERAL(TMP190, "\'none\', \'boehm\' or \'refc\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP191, "\'none\', \'speed\' or \'size\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP192, "\'gui\', \'console\' or \'lib\' expected, but \'$1\' found", 50);
STRING_LITERAL(TMP193, "unknown OS: \'$1\'", 16);
STRING_LITERAL(TMP194, "unknown CPU: \'$1\'", 17);
STRING_LITERAL(TMP195, "\'c\', \'c++\' or \'yaml\' expected, but \'$1\' found", 45);
STRING_LITERAL(TMP196, "arguments can only be given if the \'--run\' option is selected", 61);
STRING_LITERAL(TMP197, "multiple assignment is not allowed", 34);
STRING_LITERAL(TMP198, "\':\' or \'=\' expected, but found \'$1\'", 35);
STRING_LITERAL(TMP199, "expression expected, but found \'$1\'", 35);
STRING_LITERAL(TMP200, "undeclared identifier: \'$1\'", 27);
STRING_LITERAL(TMP201, "ambiguous identifier: \'$1\' -- use a qualifier", 45);
STRING_LITERAL(TMP202, "type expected", 13);
STRING_LITERAL(TMP203, "system module needs \'$1\'", 24);
STRING_LITERAL(TMP204, "execution of an external program failed", 39);
STRING_LITERAL(TMP205, "overloaded \'$1\' leads to ambiguous calls", 40);
STRING_LITERAL(TMP206, "invalid argument for \'$1\'", 25);
STRING_LITERAL(TMP207, "statement has no effect", 23);
STRING_LITERAL(TMP208, "\'$1\' expects a type or value", 28);
STRING_LITERAL(TMP209, "\'$1\' expects an array type", 26);
STRING_LITERAL(TMP210, "\'$1\' cannot be instantiated because its body has not been compi"
"led yet", 70);
STRING_LITERAL(TMP211, "expression \'$1\' ambiguous in this context", 41);
STRING_LITERAL(TMP212, "constant division by zero", 25);
STRING_LITERAL(TMP213, "ordinal type expected", 21);
STRING_LITERAL(TMP214, "ordinal or float type expected", 30);
STRING_LITERAL(TMP215, "over- or underflow", 18);
STRING_LITERAL(TMP216, "cannot evalutate \'$1\' because type is not defined completely", 60);
STRING_LITERAL(TMP217, "\'chr\' expects an int in the range 0..255", 40);
STRING_LITERAL(TMP218, "\'dynlib\' requires \'exportc\'", 27);
STRING_LITERAL(TMP219, "undeclared field: \'$1\'", 22);
STRING_LITERAL(TMP220, "attempt to access a nil address", 31);
STRING_LITERAL(TMP221, "index out of bounds", 19);
STRING_LITERAL(TMP222, "index types do not match", 24);
STRING_LITERAL(TMP223, "\'[]\' operator invalid for this type", 35);
STRING_LITERAL(TMP224, "value out of set bounds", 23);
STRING_LITERAL(TMP225, "field initialized twice: \'$1\'", 29);
STRING_LITERAL(TMP226, "field \'$1\' not initialized", 26);
STRING_LITERAL(TMP227, "expression \'$1\' cannot be called", 32);
STRING_LITERAL(TMP228, "expression has no type", 22);
STRING_LITERAL(TMP229, "expression \'$1\' has no type (or is ambiguous)", 45);
STRING_LITERAL(TMP230, "\'cast\' not allowed in safe mode", 31);
STRING_LITERAL(TMP231, "expression cannot be casted to $1", 33);
STRING_LITERAL(TMP232, "\',\' or \')\' expected", 19);
STRING_LITERAL(TMP233, "\'{\' or \'(\' expected", 19);
STRING_LITERAL(TMP234, "section (\'type\', \'proc\', etc.) expected", 39);
STRING_LITERAL(TMP235, "range expected", 14);
STRING_LITERAL(TMP236, "\'magic\' only allowed in system module", 37);
STRING_LITERAL(TMP237, "power of two expected", 21);
STRING_LITERAL(TMP238, "string literal may not be empty", 31);
STRING_LITERAL(TMP239, "calling convention expected", 27);
STRING_LITERAL(TMP240, "a proc can only have one calling convention", 43);
STRING_LITERAL(TMP241, "symbol must be imported if \'lib\' pragma is used", 47);
STRING_LITERAL(TMP242, "expression must be of type \'bool\'", 33);
STRING_LITERAL(TMP243, "constant expression expected", 28);
STRING_LITERAL(TMP244, "duplicate case label", 20);
STRING_LITERAL(TMP245, "range is empty", 14);
STRING_LITERAL(TMP246, "selector must be of an ordinal type, float or string", 52);
STRING_LITERAL(TMP247, "selector must be of an ordinal type", 35);
STRING_LITERAL(TMP248, "ord($1) must not be negative", 28);
STRING_LITERAL(TMP249, "len($1) must be less than 32768", 31);
STRING_LITERAL(TMP250, "wrong number of variables", 25);
STRING_LITERAL(TMP251, "only a \'ref object\' can be raised", 33);
STRING_LITERAL(TMP252, "\'break\' only allowed in loop construct", 38);
STRING_LITERAL(TMP253, "type \'$1\' has unknown size", 26);
STRING_LITERAL(TMP254, "a constant can only be initialized with a constant expression", 61);
STRING_LITERAL(TMP255, "a constant needs a value", 24);
STRING_LITERAL(TMP256, "the result type cannot be on open array", 39);
STRING_LITERAL(TMP257, "computing the type\'s size produced an overflow", 46);
STRING_LITERAL(TMP258, "set is too large", 16);
STRING_LITERAL(TMP259, "base type of a set must be an ordinal", 37);
STRING_LITERAL(TMP260, "inheritance only works with non-final objects", 45);
STRING_LITERAL(TMP261, "inheritance only works with an enum", 35);
STRING_LITERAL(TMP262, "illegal recursion in type \'$1\'", 30);
STRING_LITERAL(TMP263, "cannot instantiate: \'$1\'", 24);
STRING_LITERAL(TMP264, "expression has no address", 25);
STRING_LITERAL(TMP265, "address of \'$1\' may not escape its stack frame", 46);
STRING_LITERAL(TMP266, "for a \'var\' type a variable needs to be passed", 46);
STRING_LITERAL(TMP267, "type mismatch", 13);
STRING_LITERAL(TMP268, "type mismatch: got (", 20);
STRING_LITERAL(TMP269, "but expected one of: ", 21);
STRING_LITERAL(TMP270, "but expected \'$1\'", 17);
STRING_LITERAL(TMP271, "ambiguous call; both $1 and $2 match for: $3", 44);
STRING_LITERAL(TMP272, "wrong number of arguments", 25);
STRING_LITERAL(TMP273, "\'$1\' cannot be passed to a procvar", 34);
STRING_LITERAL(TMP274, "$1 cannot be declared in parameter declaration", 46);
STRING_LITERAL(TMP275, "pragmas are only allowed in the header of a proc", 48);
STRING_LITERAL(TMP276, "implementation of \'$1\' is not allowed", 37);
STRING_LITERAL(TMP277, "implementation of \'$1\' expected", 31);
STRING_LITERAL(TMP278, "no symbol to borrow from found", 30);
STRING_LITERAL(TMP279, "value returned by statement has to be discarded", 47);
STRING_LITERAL(TMP280, "statement returns no value that can be discarded", 48);
STRING_LITERAL(TMP281, "conversion from $1 to $2 is invalid", 35);
STRING_LITERAL(TMP282, "cannot bind parameter \'$1\' twice", 32);
STRING_LITERAL(TMP283, "invalid order in array constructor", 34);
STRING_LITERAL(TMP284, "invalid order in enum \'$1\'", 26);
STRING_LITERAL(TMP285, "enum \'$1\' has holes", 19);
STRING_LITERAL(TMP286, "\'except\' or \'finally\' expected", 30);
STRING_LITERAL(TMP287, "after catch all \'except\' or \'finally\' no section may follow", 59);
STRING_LITERAL(TMP288, "option expected, but found \'$1\'", 31);
STRING_LITERAL(TMP289, "\'$1\' is not a label", 19);
STRING_LITERAL(TMP290, "not all cases are covered", 25);
STRING_LITERAL(TMP291, "unknown substitution variable: \'$1\'", 35);
STRING_LITERAL(TMP292, "complex statement requires indentation", 38);
STRING_LITERAL(TMP293, "\'$1\' is not callable", 20);
STRING_LITERAL(TMP294, "no pragmas allowed for $1", 25);
STRING_LITERAL(TMP295, "no generic parameters allowed for $1", 36);
STRING_LITERAL(TMP296, "invalid param kind: \'$1\'", 24);
STRING_LITERAL(TMP297, "default argument invalid", 24);
STRING_LITERAL(TMP298, "named parameter has to be an identifier", 39);
STRING_LITERAL(TMP299, "no return type allowed for $1", 29);
STRING_LITERAL(TMP300, "a type conversion needs exactly one argument", 44);
STRING_LITERAL(TMP301, "invalid pragma: $1", 18);
STRING_LITERAL(TMP302, "$1 not allowed here", 19);
STRING_LITERAL(TMP303, "invalid control flow: $1", 24);
STRING_LITERAL(TMP304, "invalid type: \'$1\'", 18);
STRING_LITERAL(TMP305, "\'[]\' needs a pointer or reference type", 38);
STRING_LITERAL(TMP306, "invalid expression", 18);
STRING_LITERAL(TMP307, "invalid expression: \'$1\'", 24);
STRING_LITERAL(TMP308, "enum has no value \'$1\'", 22);
STRING_LITERAL(TMP309, "named expression expected", 25);
STRING_LITERAL(TMP310, "named expression not allowed here", 33);
STRING_LITERAL(TMP311, "\'$1\' expects one type parameter", 31);
STRING_LITERAL(TMP312, "array expects two type parameters", 33);
STRING_LITERAL(TMP313, "invalid visibility: \'$1\'", 24);
STRING_LITERAL(TMP314, "initialization not allowed here", 31);
STRING_LITERAL(TMP315, "\'$1\' cannot be assigned to", 26);
STRING_LITERAL(TMP316, "iterators can only be defined at the module\'s top level", 55);
STRING_LITERAL(TMP317, "$1 needs a return type", 22);
STRING_LITERAL(TMP318, "no return type declared", 23);
STRING_LITERAL(TMP319, "invalid command: \'$1\'", 21);
STRING_LITERAL(TMP320, "\'$1\' is only allowed at top level", 33);
STRING_LITERAL(TMP321, "\'$1\' needs a parameter that has an object type", 46);
STRING_LITERAL(TMP322, "template/macro instantiation too nested", 39);
STRING_LITERAL(TMP323, "instantiation from here", 23);
STRING_LITERAL(TMP324, "invalid index value for tuple subscript", 39);
STRING_LITERAL(TMP325, "command expects a filename argument", 35);
STRING_LITERAL(TMP326, "please, specify a main module in the project configuration file", 63);
STRING_LITERAL(TMP327, "invalid section start", 21);
STRING_LITERAL(TMP328, "grid table is not implemented", 29);
STRING_LITERAL(TMP329, "general parse error", 19);
STRING_LITERAL(TMP330, "new section expected", 20);
STRING_LITERAL(TMP331, "whitespace expected, got \'$1\'", 29);
STRING_LITERAL(TMP332, "\'$1\' is no valid index file", 27);
STRING_LITERAL(TMP333, "cannot render reStructuredText element \'$1\'", 43);
STRING_LITERAL(TMP334, "type \'var var\' is not allowed", 29);
STRING_LITERAL(TMP335, "instantiate \'$1\' explicitely", 28);
STRING_LITERAL(TMP336, "\'$1\' expects two arguments", 26);
STRING_LITERAL(TMP337, "\'$1\' expects object types", 25);
STRING_LITERAL(TMP338, "\'$1\' can never be of this subtype", 33);
STRING_LITERAL(TMP339, "interpretation requires too many iterations", 43);
STRING_LITERAL(TMP340, "cannot evaluate \'$1\'", 20);
STRING_LITERAL(TMP341, "field \'$1\' cannot be found", 26);
STRING_LITERAL(TMP342, "invalid conversion from type \'$1\'", 33);
STRING_LITERAL(TMP343, "assertion failed", 16);
STRING_LITERAL(TMP344, "cannot generate code for \'$1\'", 29);
STRING_LITERAL(TMP345, "$1 requires one parameter", 25);
STRING_LITERAL(TMP346, "unhandled exception: $1", 23);
STRING_LITERAL(TMP347, "macro returned a cyclic abstract syntax tree", 44);
STRING_LITERAL(TMP348, "\'$1\' is no macro or template", 28);
STRING_LITERAL(TMP349, "\'$1\' can have side effects", 26);
STRING_LITERAL(TMP350, "iterator within for loop context expected", 41);
STRING_LITERAL(TMP351, "\'let\' symbol requires an initialization", 39);
STRING_LITERAL(TMP352, "a thread var cannot be initialized explicitly", 45);
STRING_LITERAL(TMP353, "usage of \'$1\' is a user-defined error", 37);
STRING_LITERAL(TMP354, "illegal capture \'$1\'", 20);
STRING_LITERAL(TMP355, "\'$1\' cannot have \'closure\' calling convention", 45);
STRING_LITERAL(TMP356, "\'$1\' can only be used in compile-time context", 45);
STRING_LITERAL(TMP357, "cannot open \'$1\' [CannotOpenFile]", 33);
STRING_LITERAL(TMP358, "octal escape sequences do not exist; leading zero is ignored [O"
"ctalEscape]", 74);
STRING_LITERAL(TMP359, "\'$1\' is never read [XIsNeverRead]", 33);
STRING_LITERAL(TMP360, "\'$1\' might not have been initialized [XmightNotBeenInit]", 56);
STRING_LITERAL(TMP361, "\'$1\' is deprecated [Deprecated]", 31);
STRING_LITERAL(TMP362, "config file \'$1\' is deprecated [ConfigDeprecated]", 49);
STRING_LITERAL(TMP363, "\'l\' should not be used as an identifier; may look like \'1\' (one"
") [SmallLshouldNotBeUsed]", 88);
STRING_LITERAL(TMP364, "unknown magic \'$1\' might crash the compiler [UnknownMagic]", 58);
STRING_LITERAL(TMP365, "redefinition of label \'$1\' [RedefinitionOfLabel]", 48);
STRING_LITERAL(TMP366, "unknown substitution \'$1\' [UnknownSubstitutionX]", 48);
STRING_LITERAL(TMP367, "language \'$1\' not supported [LanguageXNotSupported]", 51);
STRING_LITERAL(TMP368, "comment \'$1\' ignored [CommentXIgnored]", 38);
STRING_LITERAL(TMP369, "\'nil\' statement is deprecated; use an empty \'discard\' statement"
" instead [NilStmt]", 81);
STRING_LITERAL(TMP370, "thread analysis incomplete due to unknown call \'$1\' [AnalysisLo"
"ophole]", 70);
STRING_LITERAL(TMP371, "possible inconsistency of thread local heaps [DifferentHeaps]", 61);
STRING_LITERAL(TMP372, "write to foreign heap [WriteToForeignHeap]", 42);
STRING_LITERAL(TMP373, "implicit closure convention: \'$1\' [ImplicitClosure]", 51);
STRING_LITERAL(TMP374, "each identifier is a tuple [EachIdentIsTuple]", 45);
STRING_LITERAL(TMP375, "shadowed identifier: \'$1\' [ShadowIdent]", 39);
STRING_LITERAL(TMP376, "Cannot prove that \'$1\' is initialized. This will become a compi"
"le time error in the future. [ProveInit]", 103);
STRING_LITERAL(TMP377, "cannot prove that field \'$1\' is accessible [ProveField]", 55);
STRING_LITERAL(TMP378, "cannot prove index \'$1\' is valid [ProveIndex]", 45);
STRING_LITERAL(TMP379, "\'$1\' might not have been initialized [Uninit]", 45);
STRING_LITERAL(TMP380, "$1 [User]", 9);
STRING_LITERAL(TMP381, "operation successful [Success]", 30);
STRING_LITERAL(TMP382, "operation successful ($# lines compiled; $# sec total; $#) [Suc"
"cessX]", 69);
STRING_LITERAL(TMP383, "line too long [LineTooLong]", 27);
STRING_LITERAL(TMP384, "\'$1\' is declared but not used [XDeclaredButNotUsed]", 51);
STRING_LITERAL(TMP385, "conversion to base object is not needed [ConvToBaseNotNeeded]", 61);
STRING_LITERAL(TMP386, "conversion from $1 to itself is pointless [ConvFromXtoItselfNot"
"Needed]", 70);
STRING_LITERAL(TMP387, "expression evaluates always to \'$1\' [ExprAlwaysX]", 49);
STRING_LITERAL(TMP388, "quit() called [QuitCalled]", 26);
STRING_LITERAL(TMP389, "$1 [Processing]", 15);
STRING_LITERAL(TMP390, "generated code listing: [CodeBegin]", 35);
STRING_LITERAL(TMP391, "end of listing [CodeEnd]", 24);
STRING_LITERAL(TMP392, "used config file \'$1\' [Conf]", 28);
STRING_LITERAL(TMP393, "added path: \'$1\' [Path]", 23);
STRING_LITERAL(TMP394, "condition is always true: \'$1\' [Condtrue]", 41);
STRING_LITERAL(TMP395, "$1 [Pattern]", 12);
NIM_CONST TY128266 msgkindtostr_128265 = {((NimStringDesc*) &TMP139),
((NimStringDesc*) &TMP140),
((NimStringDesc*) &TMP141),
((NimStringDesc*) &TMP142),
((NimStringDesc*) &TMP143),
((NimStringDesc*) &TMP144),
((NimStringDesc*) &TMP145),
((NimStringDesc*) &TMP146),
((NimStringDesc*) &TMP147),
((NimStringDesc*) &TMP148),
((NimStringDesc*) &TMP149),
((NimStringDesc*) &TMP150),
((NimStringDesc*) &TMP151),
((NimStringDesc*) &TMP152),
((NimStringDesc*) &TMP153),
((NimStringDesc*) &TMP154),
((NimStringDesc*) &TMP155),
((NimStringDesc*) &TMP156),
((NimStringDesc*) &TMP157),
((NimStringDesc*) &TMP158),
((NimStringDesc*) &TMP159),
((NimStringDesc*) &TMP160),
((NimStringDesc*) &TMP161),
((NimStringDesc*) &TMP162),
((NimStringDesc*) &TMP163),
((NimStringDesc*) &TMP164),
((NimStringDesc*) &TMP165),
((NimStringDesc*) &TMP166),
((NimStringDesc*) &TMP167),
((NimStringDesc*) &TMP168),
((NimStringDesc*) &TMP169),
((NimStringDesc*) &TMP170),
((NimStringDesc*) &TMP171),
((NimStringDesc*) &TMP172),
((NimStringDesc*) &TMP173),
((NimStringDesc*) &TMP174),
((NimStringDesc*) &TMP175),
((NimStringDesc*) &TMP176),
((NimStringDesc*) &TMP177),
((NimStringDesc*) &TMP178),
((NimStringDesc*) &TMP179),
((NimStringDesc*) &TMP180),
((NimStringDesc*) &TMP181),
((NimStringDesc*) &TMP182),
((NimStringDesc*) &TMP183),
((NimStringDesc*) &TMP184),
((NimStringDesc*) &TMP185),
((NimStringDesc*) &TMP186),
((NimStringDesc*) &TMP187),
((NimStringDesc*) &TMP188),
((NimStringDesc*) &TMP189),
((NimStringDesc*) &TMP190),
((NimStringDesc*) &TMP191),
((NimStringDesc*) &TMP192),
((NimStringDesc*) &TMP193),
((NimStringDesc*) &TMP194),
((NimStringDesc*) &TMP195),
((NimStringDesc*) &TMP196),
((NimStringDesc*) &TMP197),
((NimStringDesc*) &TMP198),
((NimStringDesc*) &TMP199),
((NimStringDesc*) &TMP200),
((NimStringDesc*) &TMP201),
((NimStringDesc*) &TMP202),
((NimStringDesc*) &TMP203),
((NimStringDesc*) &TMP204),
((NimStringDesc*) &TMP205),
((NimStringDesc*) &TMP206),
((NimStringDesc*) &TMP207),
((NimStringDesc*) &TMP208),
((NimStringDesc*) &TMP209),
((NimStringDesc*) &TMP210),
((NimStringDesc*) &TMP211),
((NimStringDesc*) &TMP212),
((NimStringDesc*) &TMP213),
((NimStringDesc*) &TMP214),
((NimStringDesc*) &TMP215),
((NimStringDesc*) &TMP216),
((NimStringDesc*) &TMP217),
((NimStringDesc*) &TMP218),
((NimStringDesc*) &TMP219),
((NimStringDesc*) &TMP220),
((NimStringDesc*) &TMP221),
((NimStringDesc*) &TMP222),
((NimStringDesc*) &TMP223),
((NimStringDesc*) &TMP224),
((NimStringDesc*) &TMP225),
((NimStringDesc*) &TMP226),
((NimStringDesc*) &TMP227),
((NimStringDesc*) &TMP228),
((NimStringDesc*) &TMP229),
((NimStringDesc*) &TMP230),
((NimStringDesc*) &TMP231),
((NimStringDesc*) &TMP232),
((NimStringDesc*) &TMP233),
((NimStringDesc*) &TMP234),
((NimStringDesc*) &TMP235),
((NimStringDesc*) &TMP236),
((NimStringDesc*) &TMP237),
((NimStringDesc*) &TMP238),
((NimStringDesc*) &TMP239),
((NimStringDesc*) &TMP240),
((NimStringDesc*) &TMP241),
((NimStringDesc*) &TMP242),
((NimStringDesc*) &TMP243),
((NimStringDesc*) &TMP244),
((NimStringDesc*) &TMP245),
((NimStringDesc*) &TMP246),
((NimStringDesc*) &TMP247),
((NimStringDesc*) &TMP248),
((NimStringDesc*) &TMP249),
((NimStringDesc*) &TMP250),
((NimStringDesc*) &TMP251),
((NimStringDesc*) &TMP252),
((NimStringDesc*) &TMP253),
((NimStringDesc*) &TMP254),
((NimStringDesc*) &TMP255),
((NimStringDesc*) &TMP256),
((NimStringDesc*) &TMP257),
((NimStringDesc*) &TMP258),
((NimStringDesc*) &TMP259),
((NimStringDesc*) &TMP260),
((NimStringDesc*) &TMP261),
((NimStringDesc*) &TMP262),
((NimStringDesc*) &TMP263),
((NimStringDesc*) &TMP264),
((NimStringDesc*) &TMP265),
((NimStringDesc*) &TMP266),
((NimStringDesc*) &TMP267),
((NimStringDesc*) &TMP268),
((NimStringDesc*) &TMP269),
((NimStringDesc*) &TMP270),
((NimStringDesc*) &TMP271),
((NimStringDesc*) &TMP272),
((NimStringDesc*) &TMP273),
((NimStringDesc*) &TMP274),
((NimStringDesc*) &TMP275),
((NimStringDesc*) &TMP276),
((NimStringDesc*) &TMP277),
((NimStringDesc*) &TMP278),
((NimStringDesc*) &TMP279),
((NimStringDesc*) &TMP280),
((NimStringDesc*) &TMP281),
((NimStringDesc*) &TMP282),
((NimStringDesc*) &TMP283),
((NimStringDesc*) &TMP284),
((NimStringDesc*) &TMP285),
((NimStringDesc*) &TMP286),
((NimStringDesc*) &TMP287),
((NimStringDesc*) &TMP288),
((NimStringDesc*) &TMP289),
((NimStringDesc*) &TMP290),
((NimStringDesc*) &TMP291),
((NimStringDesc*) &TMP292),
((NimStringDesc*) &TMP293),
((NimStringDesc*) &TMP294),
((NimStringDesc*) &TMP295),
((NimStringDesc*) &TMP296),
((NimStringDesc*) &TMP297),
((NimStringDesc*) &TMP298),
((NimStringDesc*) &TMP299),
((NimStringDesc*) &TMP300),
((NimStringDesc*) &TMP301),
((NimStringDesc*) &TMP302),
((NimStringDesc*) &TMP303),
((NimStringDesc*) &TMP304),
((NimStringDesc*) &TMP305),
((NimStringDesc*) &TMP306),
((NimStringDesc*) &TMP307),
((NimStringDesc*) &TMP308),
((NimStringDesc*) &TMP309),
((NimStringDesc*) &TMP310),
((NimStringDesc*) &TMP311),
((NimStringDesc*) &TMP312),
((NimStringDesc*) &TMP313),
((NimStringDesc*) &TMP314),
((NimStringDesc*) &TMP315),
((NimStringDesc*) &TMP316),
((NimStringDesc*) &TMP317),
((NimStringDesc*) &TMP318),
((NimStringDesc*) &TMP319),
((NimStringDesc*) &TMP320),
((NimStringDesc*) &TMP321),
((NimStringDesc*) &TMP322),
((NimStringDesc*) &TMP323),
((NimStringDesc*) &TMP324),
((NimStringDesc*) &TMP325),
((NimStringDesc*) &TMP326),
((NimStringDesc*) &TMP162),
((NimStringDesc*) &TMP327),
((NimStringDesc*) &TMP328),
((NimStringDesc*) &TMP329),
((NimStringDesc*) &TMP330),
((NimStringDesc*) &TMP331),
((NimStringDesc*) &TMP332),
((NimStringDesc*) &TMP333),
((NimStringDesc*) &TMP334),
((NimStringDesc*) &TMP335),
((NimStringDesc*) &TMP336),
((NimStringDesc*) &TMP337),
((NimStringDesc*) &TMP338),
((NimStringDesc*) &TMP339),
((NimStringDesc*) &TMP340),
((NimStringDesc*) &TMP341),
((NimStringDesc*) &TMP342),
((NimStringDesc*) &TMP343),
((NimStringDesc*) &TMP344),
((NimStringDesc*) &TMP345),
((NimStringDesc*) &TMP346),
((NimStringDesc*) &TMP347),
((NimStringDesc*) &TMP348),
((NimStringDesc*) &TMP349),
((NimStringDesc*) &TMP350),
((NimStringDesc*) &TMP351),
((NimStringDesc*) &TMP352),
((NimStringDesc*) &TMP353),
((NimStringDesc*) &TMP354),
((NimStringDesc*) &TMP355),
((NimStringDesc*) &TMP356),
((NimStringDesc*) &TMP143),
((NimStringDesc*) &TMP357),
((NimStringDesc*) &TMP358),
((NimStringDesc*) &TMP359),
((NimStringDesc*) &TMP360),
((NimStringDesc*) &TMP361),
((NimStringDesc*) &TMP362),
((NimStringDesc*) &TMP363),
((NimStringDesc*) &TMP364),
((NimStringDesc*) &TMP365),
((NimStringDesc*) &TMP366),
((NimStringDesc*) &TMP367),
((NimStringDesc*) &TMP368),
((NimStringDesc*) &TMP369),
((NimStringDesc*) &TMP370),
((NimStringDesc*) &TMP371),
((NimStringDesc*) &TMP372),
((NimStringDesc*) &TMP373),
((NimStringDesc*) &TMP374),
((NimStringDesc*) &TMP375),
((NimStringDesc*) &TMP376),
((NimStringDesc*) &TMP377),
((NimStringDesc*) &TMP378),
((NimStringDesc*) &TMP379),
((NimStringDesc*) &TMP380),
((NimStringDesc*) &TMP381),
((NimStringDesc*) &TMP382),
((NimStringDesc*) &TMP383),
((NimStringDesc*) &TMP384),
((NimStringDesc*) &TMP385),
((NimStringDesc*) &TMP386),
((NimStringDesc*) &TMP387),
((NimStringDesc*) &TMP388),
((NimStringDesc*) &TMP389),
((NimStringDesc*) &TMP390),
((NimStringDesc*) &TMP391),
((NimStringDesc*) &TMP392),
((NimStringDesc*) &TMP393),
((NimStringDesc*) &TMP394),
((NimStringDesc*) &TMP395),
((NimStringDesc*) &TMP380)}
;
STRING_LITERAL(TMP396, "Error: $1", 9);
STRING_LITERAL(TMP397, "Warning: $1", 11);
STRING_LITERAL(TMP398, "Hint: $1", 8);
STRING_LITERAL(TMP400, "ropes: invalid format string: ", 30);
STRING_LITERAL(TMP401, "ropes: token too long: ", 23);
STRING_LITERAL(TMP1078, "$1($2, $3) Error: $4", 20);
STRING_LITERAL(TMP1079, "$1($2, $3) Warning: $4", 22);
STRING_LITERAL(TMP1080, "$1($2, $3) Hint: $4", 19);
STRING_LITERAL(TMP1081, "  ", 2);
STRING_LITERAL(TMP1095, "compiler/msgs.nim", 17);
NIM_CONST TY71082 TMP1094 = {((NimStringDesc*) &TMP1095),
807}
;
STRING_LITERAL(TMP1774, "\015\012", 2);
STRING_LITERAL(TMP2430, "suggest done", 12);
NIM_CONST TY71082 TMP3123 = {((NimStringDesc*) &TMP1095),
814}
;
STRING_LITERAL(TMP4199, "\012", 1);
STRING_LITERAL(TMP4200, "(", 1);
STRING_LITERAL(TMP4201, ", ", 2);
STRING_LITERAL(TMP4202, "filename", 8);
STRING_LITERAL(TMP4203, ": ", 2);
STRING_LITERAL(TMP4204, "line", 4);
STRING_LITERAL(TMP4205, ")", 1);
ttable128335 filenametoindextbl_128414;
extern TNimType NTI128335; /* TTable */
TY128415* fileinfos_128435;
TNimType NTI128306; /* TFileInfo */
extern TNimType NTI143; /* string */
extern TNimType NTI126005; /* PRope */
TNimType NTI128316; /* seq[PRope] */
TNimType NTI128415; /* seq[TFileInfo] */
extern tgcheap40416 gch_40442;
NI32 systemfileidx_128436;
extern NimStringDesc* tnl_123580;
extern NU32 gglobaloptions_105108;
tlineinfo128308 gcmdlineinfo_128801;
tlineinfo128308 gcodegenlineinfo_128820;
NU64 gnotes_128867;
NI gerrorcounter_128868;
NI ghintcounter_128869;
NI gwarncounter_128870;
NI gerrormax_128871;
NI gsilence_128872;
tsocketimpl110806* stdoutsocket_128873;
TY128959* msgcontext_128979;
TNimType NTI128308; /* TLineInfo */
extern TNimType NTI109; /* int16 */
extern TNimType NTI111; /* int32 */
TNimType NTI128959; /* seq[TLineInfo] */
TY128959* checkpoints_129174;
tlineinfo128308 opttrackpos_129177;
tlineinfo128308 lasterror_129528;
extern TY126103 errorhandler_126108;
extern NU8 gcmd_105110;
extern NIM_BOOL glistfullpaths_105121;
extern NU32 goptions_105106;
extern NI gverbosity_105116;
extern NI8 gexitcode_105109;
extern TNimType NTI1053; /* EInvalidValue */
TNimType NTI128310; /* ERecoverableError */
TNimType NTI128828; /* ref ERecoverableError */
extern TSafePoint* exchandler_11828;
extern TNimType NTI1033; /* EIO */
extern E_Base* currexception_11830;
TNimType NTI128003; /* TMsgKind */
TNimType NTI128302; /* TNoteKind */
TNimType NTI128304; /* TNoteKinds */
extern NIM_BOOL isserving_105122;
extern NI32 gdirtybufferidx_105123;
extern TNimType NTI1025; /* E_Base */
TNimType NTI128312; /* ESuggestDone */
TNimType NTI128926; /* ref ESuggestDone */
extern TNimType NTI128340; /* TKeyValuePairSeq */
N_NIMCALL(void, TMP127)(void* p, NI op) {
	TY128316* a;
	NI LOC1;
	a = (TY128316*)p;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1], op);
	}
}
N_NIMCALL(void, TMP128)(void* p, NI op) {
	TY128415* a;
	NI LOC1;
	a = (TY128415*)p;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	nimGCvisit((void*)a->data[LOC1].Fullpath, op);
	nimGCvisit((void*)a->data[LOC1].Projpath, op);
	nimGCvisit((void*)a->data[LOC1].Quotedname, op);
	nimGCvisit((void*)a->data[LOC1].Lines, op);
	}
}

static N_INLINE(tcell38449*, usrtocell_41843)(void* usr) {
	tcell38449* result;
	result = 0;
	result = ((tcell38449*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(tcell38449))))));
	return result;
}

static N_INLINE(void, rtladdzct_43002)(tcell38449* c) {
	addzct_41815(&gch_40442.Zct, c);
}

static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	tcell38449* c;
	c = usrtocell_41843(p);
	{
		(*c).Refcount -= 8;
		if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA3;
		rtladdzct_43002(c);
	}
	LA3: ;
}

static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));
	(*dest).Sup.len += (*src).Sup.len;
}

static N_INLINE(void, appendChar)(NimStringDesc* dest, NIM_CHAR c) {
	(*dest).data[((*dest).Sup.len)- 0] = c;
	(*dest).data[((NI64)((*dest).Sup.len + 1))- 0] = 0;
	(*dest).Sup.len += 1;
}

N_NIMCALL(NimStringDesc*, tocchar_128440)(NIM_CHAR c) {
	NimStringDesc* result;
	result = 0;
	switch (((NU8)(c))) {
	case 0 ... 31:
	case 128 ... 255:
	{
		NimStringDesc* LOC2;
		NimStringDesc* LOC3;
		LOC2 = 0;
		LOC3 = 0;
		LOC3 = nsuToOctal(c);
		LOC2 = rawNewString(LOC3->Sup.len + 1);
appendChar(LOC2, 92);
appendString(LOC2, LOC3);
		result = LOC2;
	}
	break;
	case 39:
	case 34:
	case 92:
	{
		NimStringDesc* LOC5;
		LOC5 = 0;
		LOC5 = rawNewString(2);
appendChar(LOC5, 92);
appendChar(LOC5, c);
		result = LOC5;
	}
	break;
	default:
	{
		result = nimCharToStr(c);
	}
	break;
	}
	return result;
}

N_NIMCALL(trope126007*, makecstring_128446)(NimStringDesc* s) {
	trope126007* result;
	NimStringDesc* res;
	NI i_128460;
	NI HEX3Atmp_128464;
	NI res_128466;
	trope126007* LOC8;
	result = 0;
	result = NIM_NIL;
	res = copyString(((NimStringDesc*) &TMP129));
	i_128460 = 0;
	HEX3Atmp_128464 = 0;
	HEX3Atmp_128464 = (NI64)(s->Sup.len - 1);
	res_128466 = 0;
	while (1) {
		NimStringDesc* LOC7;
		if (!(res_128466 <= HEX3Atmp_128464)) goto LA1;
		i_128460 = res_128466;
		{
			trope126007* LOC6;
			if (!(((NI) ((NI64)((NI64)(i_128460 + 1) % 64))) == 0)) goto LA4;
			res = addChar(res, 34);
			res = resizeString(res, tnl_123580->Sup.len + 0);
appendString(res, tnl_123580);
			LOC6 = 0;
			LOC6 = torope_126058(res);
			app_126040(&result, LOC6);
			res = setLengthStr(res, 1);
			res->data[0] = 34;
		}
		LA4: ;
		LOC7 = 0;
		LOC7 = tocchar_128440(s->data[i_128460]);
		res = resizeString(res, LOC7->Sup.len + 0);
appendString(res, LOC7);
		res_128466 += 1;
	} LA1: ;
	res = addChar(res, 34);
	LOC8 = 0;
	LOC8 = torope_126058(res);
	app_126040(&result, LOC8);
	return result;
}

N_NIMCALL(void, newfileinfo_128471)(NimStringDesc* fullpath, NimStringDesc* projpath, tfileinfo128306* Result) {
	NimStringDesc* LOC1;
	unsureAsgnRef((void**) &(*Result).Fullpath, copyString(fullpath));
	unsureAsgnRef((void**) &(*Result).Projpath, copyString(projpath));
	LOC1 = 0;
	LOC1 = nosextractFilename(projpath);
	unsureAsgnRef((void**) &(*Result).Quotedname, makecstring_128446(LOC1));
	{
		NIM_BOOL LOC4;
		LOC4 = ((gglobaloptions_105108 &(1<<((((NU8) 31))&31)))!=0);
		if (LOC4) goto LA5;
		LOC4 = NIM_TRUE;
		LA5: ;
		if (!LOC4) goto LA6;
		unsureAsgnRef((void**) &(*Result).Lines, (TY128316*) newSeq((&NTI128316), 0));
	}
	LA6: ;
}

static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	{
		tcell38449* c;
		if (!!((src == NIM_NIL))) goto LA3;
		c = usrtocell_41843(src);
		(*c).Refcount += 8;
	}
	LA3: ;
	{
		tcell38449* c;
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		c = usrtocell_41843((*dest));
		{
			(*c).Refcount -= 8;
			if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA11;
			rtladdzct_43002(c);
		}
		LA11: ;
	}
	LA7: ;
	(*dest) = src;
}

N_NIMCALL(tlineinfo128308, newlineinfo_128768)(NI32 fileinfoidx, NI line, NI col) {
	tlineinfo128308 result;
	memset((void*)&result, 0, sizeof(result));
	result.Fileindex = fileinfoidx;
	result.Line = ((NI16) (line));
	result.Col = ((NI16) (col));
	return result;
}
N_NIMCALL(void, TMP135)(void* p, NI op) {
	TY128959* a;
	NI LOC1;
	a = (TY128959*)p;
	for (LOC1 = 0; LOC1 < a->Sup.len; LOC1++) {
	}
}

N_NIMCALL(tlineinfo128308, unknownlineinfo_128954)(void) {
	tlineinfo128308 result;
	memset((void*)&result, 0, sizeof(result));
	result.Line = ((NI16) -1);
	result.Col = ((NI16) -1);
	result.Fileindex = ((NI32) -1);
	return result;
}

N_NIMCALL(NIM_BOOL, HEX3DHEX3D_129409)(tlineinfo128308 a, tlineinfo128308 b) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	result = 0;
	LOC1 = (a.Line == b.Line);
	if (!(LOC1)) goto LA2;
	LOC1 = (a.Fileindex == b.Fileindex);
	LA2: ;
	result = LOC1;
	return result;
}

N_NIMCALL(void, msgwriteln_129225)(NimStringDesc* s) {
	{
		if (!(gsilence_128872 == 0)) goto LA3;
		{
			NIM_BOOL LOC7;
			LOC7 = (gcmd_105110 == ((NU8) 14));
			if (!(LOC7)) goto LA8;
			LOC7 = !(((gglobaloptions_105108 &(1<<((((NU8) 7))&31)))!=0));
			LA8: ;
			if (!LOC7) goto LA9;
			goto BeforeRet;
		}
		LA9: ;
		{
			TY129263 LOC15;
			if (!((gglobaloptions_105108 &(1<<((((NU8) 22))&31)))!=0)) goto LA13;
			memset((void*)LOC15, 0, sizeof(LOC15));
			LOC15[0] = copyString(s);
			writeln_105451(stderr, LOC15, 1);
		}
		goto LA11;
		LA13: ;
		{
			TY129263 LOC17;
			memset((void*)LOC17, 0, sizeof(LOC17));
			LOC17[0] = copyString(s);
			writeln_105451(stdout, LOC17, 1);
		}
		LA11: ;
	}
	LA3: ;
	BeforeRet: ;
}

N_NIMCALL(NimStringDesc*, tomsgfilename_129113)(tlineinfo128308 info) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(info.Fileindex < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP138));
	}
	goto LA1;
	LA3: ;
	{
		{
			if (!glistfullpaths_105121) goto LA8;
			result = copyString(fileinfos_128435->data[info.Fileindex].Fullpath);
		}
		goto LA6;
		LA8: ;
		{
			result = copyString(fileinfos_128435->data[info.Fileindex].Projpath);
		}
		LA6: ;
	}
	LA1: ;
	return result;
}

N_NIMCALL(NimStringDesc*, coordtostr_129280)(NI coord) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(coord == -1)) goto LA3;
		result = copyString(((NimStringDesc*) &TMP138));
	}
	goto LA1;
	LA3: ;
	{
		result = nimIntToStr(coord);
	}
	LA1: ;
	return result;
}

N_NIMCALL(NimStringDesc*, msgkindtostring_129286)(NU16 kind) {
	NimStringDesc* result;
	result = 0;
	result = copyString(msgkindtostr_128265[(kind)- 0]);
	return result;
}

N_NIMCALL(NimStringDesc*, getmessagestr_129292)(NU16 msg, NimStringDesc* arg) {
	NimStringDesc* result;
	NimStringDesc* LOC1;
	TY129263 LOC2;
	result = 0;
	LOC1 = 0;
	LOC1 = msgkindtostring_129286(msg);
	memset((void*)LOC2, 0, sizeof(LOC2));
	LOC2[0] = copyString(arg);
	result = nsuFormatOpenArray(LOC1, LOC2, 1);
	return result;
}

N_NIMCALL(void, writecontext_129416)(tlineinfo128308 lastinfo) {
	tlineinfo128308 info;
	NI i_129436;
	NI HEX3Atmp_129441;
	NI res_129443;
	info = lastinfo;
	i_129436 = 0;
	HEX3Atmp_129441 = 0;
	HEX3Atmp_129441 = (NI64)(msgcontext_128979->Sup.len - 1);
	res_129443 = 0;
	while (1) {
		if (!(res_129443 <= HEX3Atmp_129441)) goto LA1;
		i_129436 = res_129443;
		{
			NIM_BOOL LOC4;
			NIM_BOOL LOC5;
			NIM_BOOL LOC7;
			TY129439 LOC10;
			NimStringDesc* LOC11;
			LOC5 = HEX3DHEX3D_129409(msgcontext_128979->data[i_129436], lastinfo);
			LOC4 = !(LOC5);
			if (!(LOC4)) goto LA6;
			LOC7 = HEX3DHEX3D_129409(msgcontext_128979->data[i_129436], info);
			LOC4 = !(LOC7);
			LA6: ;
			if (!LOC4) goto LA8;
			memset((void*)LOC10, 0, sizeof(LOC10));
			LOC10[0] = tomsgfilename_129113(msgcontext_128979->data[i_129436]);
			LOC10[1] = coordtostr_129280(((NI) (msgcontext_128979->data[i_129436].Line)));
			LOC10[2] = coordtostr_129280(((NI) (msgcontext_128979->data[i_129436].Col)));
			LOC10[3] = getmessagestr_129292(((NU16) 184), ((NimStringDesc*) &TMP131));
			LOC11 = 0;
			LOC11 = nsuFormatOpenArray(((NimStringDesc*) &TMP137), LOC10, 4);
			msgwriteln_129225(LOC11);
		}
		LA8: ;
		info = msgcontext_128979->data[i_129436];
		res_129443 += 1;
	} LA1: ;
}
N_NIMCALL(void, TMP399)(void* p, NI op) {
	erecoverableerror128310* a;
	a = (erecoverableerror128310*)p;
	nimGCvisit((void*)(*a).Sup.Sup.Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.Sup.Sup.message, op);
	nimGCvisit((void*)(*a).Sup.Sup.Sup.trace, op);
}

N_NOINLINE(void, raiserecoverableerror_128822)(NimStringDesc* msg) {
	erecoverableerror128310* e_128827;
	NimStringDesc* LOC1;
	e_128827 = 0;
	e_128827 = (erecoverableerror128310*) newObj((&NTI128828), sizeof(erecoverableerror128310));
	(*e_128827).Sup.Sup.Sup.Sup.m_type = (&NTI128310);
	LOC1 = 0;
	LOC1 = (*e_128827).Sup.Sup.Sup.message; (*e_128827).Sup.Sup.Sup.message = copyStringRC1(msg);
	if (LOC1) nimGCunrefNoCycle(LOC1);
	raiseException((E_Base*)e_128827, "ERecoverableError");
}

N_NIMCALL(void, handleerror_129339)(NU16 msg, NU8 eh, NimStringDesc* s) {
	{
		if (!(msg == ((NU16) 2))) goto LA3;
		writestacktrace_11206();
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		LOC7 = (((NU16) 0) <= msg);
		if (!(LOC7)) goto LA8;
		LOC7 = (msg <= ((NU16) 2));
		LA8: ;
		if (!LOC7) goto LA9;
		{
			NIM_BOOL LOC13;
			LOC13 = NIM_FALSE;
			if (LOC13) goto LA14;
			LOC13 = (3 <= gverbosity_105116);
			LA14: ;
			if (!LOC13) goto LA15;
			writestacktrace_11206();
		}
		LA15: ;
		exit(1);
	}
	LA9: ;
	{
		NIM_BOOL LOC19;
		LOC19 = (((NU16) 0) <= msg);
		if (!(LOC19)) goto LA20;
		LOC19 = (msg <= ((NU16) 219));
		LA20: ;
		if (!LOC19) goto LA21;
		{
			NIM_BOOL LOC25;
			LOC25 = NIM_FALSE;
			if (LOC25) goto LA26;
			LOC25 = (3 <= gverbosity_105116);
			LA26: ;
			if (!LOC25) goto LA27;
			writestacktrace_11206();
		}
		LA27: ;
		gerrorcounter_128868 += 1;
		gexitcode_105109 = ((NI8) 1);
		{
			if (!(gerrormax_128871 <= gerrorcounter_128868)) goto LA31;
			exit(1);
		}
		goto LA29;
		LA31: ;
		{
			NIM_BOOL LOC34;
			LOC34 = (eh == ((NU8) 1));
			if (!(LOC34)) goto LA35;
			LOC34 = !((gcmd_105110 == ((NU8) 14)));
			LA35: ;
			if (!LOC34) goto LA36;
			exit(1);
		}
		goto LA29;
		LA36: ;
		{
			if (!(eh == ((NU8) 2))) goto LA39;
			raiserecoverableerror_128822(s);
		}
		goto LA29;
		LA39: ;
		LA29: ;
	}
	LA21: ;
}

N_NIMCALL(void, rawmessage_129448)(NU16 msg, NimStringDesc** args, NI argslen0) {
	NimStringDesc* frmt;
	NimStringDesc* s;
	NimStringDesc* LOC22;
	NimStringDesc* LOC23;
	frmt = 0;
	switch (msg) {
	case ((NU16) 0) ... ((NU16) 219):
	{
		tlineinfo128308 LOC2;
		LOC2 = unknownlineinfo_128954();
		writecontext_129416(LOC2);
		frmt = copyString(((NimStringDesc*) &TMP396));
	}
	break;
	case ((NU16) 220) ... ((NU16) 243):
	{
		tlineinfo128308 LOC12;
		{
			if (!!(((goptions_105106 &(1<<((((NU8) 11))&31)))!=0))) goto LA6;
			goto BeforeRet;
		}
		LA6: ;
		{
			if (!!(((gnotes_128867 &(IL64(1)<<(((((NU16) (msg))- 220))&IL64(63))))!=0))) goto LA10;
			goto BeforeRet;
		}
		LA10: ;
		LOC12 = unknownlineinfo_128954();
		writecontext_129416(LOC12);
		frmt = copyString(((NimStringDesc*) &TMP397));
		gwarncounter_128870 += 1;
	}
	break;
	case ((NU16) 244) ... ((NU16) 259):
	{
		{
			if (!!(((goptions_105106 &(1<<((((NU8) 12))&31)))!=0))) goto LA16;
			goto BeforeRet;
		}
		LA16: ;
		{
			if (!!(((gnotes_128867 &(IL64(1)<<(((((NU16) (msg))- 220))&IL64(63))))!=0))) goto LA20;
			goto BeforeRet;
		}
		LA20: ;
		frmt = copyString(((NimStringDesc*) &TMP398));
		ghintcounter_128869 += 1;
	}
	break;
	}
	LOC22 = 0;
	LOC22 = msgkindtostring_129286(msg);
	LOC23 = 0;
	LOC23 = nsuFormatOpenArray(LOC22, args, argslen0);
	s = nsuFormatSingleElem(frmt, LOC23);
	msgwriteln_129225(s);
	handleerror_129339(msg, ((NU8) 1), s);
	BeforeRet: ;
}

N_NIMCALL(void, rawmessage_129518)(NU16 msg, NimStringDesc* arg) {
	TY129263 LOC1;
	memset((void*)LOC1, 0, sizeof(LOC1));
	LOC1[0] = copyString(arg);
	rawmessage_129448(msg, LOC1, 1);
}

N_NIMCALL(void, internalerror_129699)(NimStringDesc* errmsg) {
	tlineinfo128308 LOC5;
	{
		if (!(gcmd_105110 == ((NU8) 14))) goto LA3;
		goto BeforeRet;
	}
	LA3: ;
	LOC5 = unknownlineinfo_128954();
	writecontext_129416(LOC5);
	rawmessage_129518(((NU16) 2), errmsg);
	BeforeRet: ;
}

N_NIMCALL(void, HEX3Aanonymous_129824)(NU8 err, NimStringDesc* msg, NIM_BOOL usewarning) {
	switch (err) {
	case ((NU8) 1):
	{
		NimStringDesc* LOC2;
		LOC2 = 0;
		LOC2 = rawNewString(msg->Sup.len + 30);
appendString(LOC2, ((NimStringDesc*) &TMP400));
appendString(LOC2, msg);
		internalerror_129699(LOC2);
	}
	break;
	case ((NU8) 2):
	{
		NimStringDesc* LOC4;
		LOC4 = 0;
		LOC4 = rawNewString(msg->Sup.len + 23);
appendString(LOC4, ((NimStringDesc*) &TMP401));
appendString(LOC4, msg);
		internalerror_129699(LOC4);
	}
	break;
	case ((NU8) 0):
	{
		NU16 LOC6;
		{
			if (!usewarning) goto LA9;
			LOC6 = ((NU16) 220);
		}
		goto LA7;
		LA9: ;
		{
			LOC6 = ((NU16) 3);
		}
		LA7: ;
		rawmessage_129518(LOC6, msg);
	}
	break;
	}
}

static N_INLINE(NIM_BOOL, canbecycleroot_41865)(tcell38449* c) {
	NIM_BOOL result;
	result = 0;
	result = !((((*(*c).Typ).flags &(1<<((((NU8) 1))&7)))!=0));
	return result;
}

static N_INLINE(void, rtladdcycleroot_42436)(tcell38449* c) {
	{
		if (!!((((NI) ((NI)((*c).Refcount & 3))) == 3))) goto LA3;
		(*c).Refcount = (NI)((NI)((*c).Refcount & -4) | 3);
		incl_39256(&gch_40442.Cycleroots, c);
	}
	LA3: ;
}

static N_INLINE(void, incref_43824)(tcell38449* c) {
	(*c).Refcount = (NI)((NU64)((*c).Refcount) + (NU64)(8));
	{
		NIM_BOOL LOC3;
		LOC3 = canbecycleroot_41865(c);
		if (!LOC3) goto LA4;
		rtladdcycleroot_42436(c);
	}
	LA4: ;
}

static N_INLINE(void, decref_43402)(tcell38449* c) {
	{
		(*c).Refcount -= 8;
		if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA3;
		rtladdzct_43002(c);
	}
	goto LA1;
	LA3: ;
	{
		NIM_BOOL LOC6;
		LOC6 = canbecycleroot_41865(c);
		if (!LOC6) goto LA7;
		rtladdcycleroot_42436(c);
	}
	goto LA1;
	LA7: ;
	LA1: ;
}

static N_INLINE(void, asgnRef)(void** dest, void* src) {
	{
		tcell38449* LOC5;
		if (!!((src == NIM_NIL))) goto LA3;
		LOC5 = usrtocell_41843(src);
		incref_43824(LOC5);
	}
	LA3: ;
	{
		tcell38449* LOC10;
		if (!!(((*dest) == NIM_NIL))) goto LA8;
		LOC10 = usrtocell_41843((*dest));
		decref_43402(LOC10);
	}
	LA8: ;
	(*dest) = src;
}

static N_INLINE(void, pushSafePoint)(TSafePoint* s) {
	(*s).hasRaiseAction = NIM_FALSE;
	(*s).prev = exchandler_11828;
	exchandler_11828 = s;
}

N_NIMCALL(NimStringDesc*, tofullpath_129095)(NI32 fileidx) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(fileidx < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP138));
	}
	goto LA1;
	LA3: ;
	{
		result = copyString(fileinfos_128435->data[fileidx].Fullpath);
	}
	LA1: ;
	return result;
}

N_NIMCALL(void, addsourceline_129718)(NI32 fileidx, NimStringDesc* line) {
	trope126007* LOC1;
	LOC1 = 0;
	LOC1 = torope_126058(line);
	fileinfos_128435->data[fileidx].Lines = (TY128316*) incrSeq(&(fileinfos_128435->data[fileidx].Lines)->Sup, sizeof(trope126007*));
	asgnRefNoCycle((void**) &fileinfos_128435->data[fileidx].Lines->data[fileinfos_128435->data[fileidx].Lines->Sup.len-1], LOC1);
}

static N_INLINE(void, popSafePoint)(void) {
	exchandler_11828 = (*exchandler_11828).prev;
}

static N_INLINE(E_Base*, getCurrentException)(void) {
	E_Base* result;
	result = 0;
	result = currexception_11830;
	return result;
}

static N_INLINE(void, popCurrentException)(void) {
	asgnRefNoCycle((void**) &currexception_11830, (*currexception_11830).parent);
}

N_NIMCALL(trope126007*, sourceline_128847)(tlineinfo128308 i) {
	trope126007* result;
	result = 0;
	{
		if (!(i.Fileindex < ((NI32) 0))) goto LA3;
		result = NIM_NIL;
		goto BeforeRet;
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		TSafePoint TMP1083;
		LOC7 = !(((gglobaloptions_105108 &(1<<((((NU8) 31))&31)))!=0));
		if (!(LOC7)) goto LA8;
		LOC7 = (fileinfos_128435->data[i.Fileindex].Lines->Sup.len == 0);
		LA8: ;
		if (!LOC7) goto LA9;
		pushSafePoint(&TMP1083);
		TMP1083.status = setjmp(TMP1083.context);
		if (TMP1083.status == 0) {
			NimStringDesc* volatile line_129765;
			NimStringDesc* volatile HEX3Atmp_129804;
			FILE* volatile f_129806;
			NimStringDesc* volatile res_129808;
			line_129765 = 0;
			HEX3Atmp_129804 = 0;
			HEX3Atmp_129804 = tofullpath_129095(i.Fileindex);
			f_129806 = open_8832(HEX3Atmp_129804, ((NU8) 0), -1);
			res_129808 = rawNewString(80);
			while (1) {
				NIM_BOOL LOC13;
				LOC13 = readline_9086(f_129806, &res_129808);
				if (!LOC13) goto LA12;
				line_129765 = res_129808;
				addsourceline_129718(i.Fileindex, line_129765);
			} LA12: ;
			fclose(f_129806);
			popSafePoint();
		}
		else {
			popSafePoint();
			if (isObj(getCurrentException()->Sup.m_type, (&NTI1033))) {
				TMP1083.status = 0;
				popCurrentException();
			}
		}
		if (TMP1083.status != 0) reraiseException();
	}
	LA9: ;
	{
		NimStringDesc* LOC20;
		if (!!((((NI) (i.Fileindex)) < fileinfos_128435->Sup.len))) goto LA18;
		LOC20 = 0;
		LOC20 = HEX24_129777(TMP1094);
		internalerror_129699(LOC20);
	}
	LA18: ;
	{
		if (!(fileinfos_128435->data[i.Fileindex].Lines->Sup.len < ((NI) (i.Line)))) goto LA23;
		result = NIM_NIL;
		goto BeforeRet;
	}
	LA23: ;
	result = fileinfos_128435->data[i.Fileindex].Lines->data[(NI16)(i.Line - ((NI16) 1))];
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, writesurroundingsrc_129530)(tlineinfo128308 info) {
	NimStringDesc* LOC1;
	trope126007* LOC2;
	NimStringDesc* LOC3;
	NimStringDesc* LOC4;
	NimStringDesc* LOC5;
	LOC1 = 0;
	LOC2 = 0;
	LOC2 = sourceline_128847(info);
	LOC3 = 0;
	LOC3 = ropetostr_126075(LOC2);
	LOC1 = rawNewString(LOC3->Sup.len + 2);
appendString(LOC1, ((NimStringDesc*) &TMP1081));
appendString(LOC1, LOC3);
	msgwriteln_129225(LOC1);
	LOC4 = 0;
	LOC5 = 0;
	LOC5 = nsuRepeatChar(((NI) (info.Col)), 32);
	LOC4 = rawNewString(LOC5->Sup.len + 3);
appendString(LOC4, ((NimStringDesc*) &TMP1081));
appendString(LOC4, LOC5);
appendChar(LOC4, 94);
	msgwriteln_129225(LOC4);
}

N_NIMCALL(void, limessage_129536)(tlineinfo128308 info, NU16 msg, NimStringDesc* arg, NU8 eh) {
	NimStringDesc* frmt;
	NIM_BOOL ignoremsg;
	NimStringDesc* s;
	TY129439 LOC12;
	frmt = 0;
	ignoremsg = NIM_FALSE;
	switch (msg) {
	case ((NU16) 0) ... ((NU16) 219):
	{
		writecontext_129416(info);
		frmt = copyString(((NimStringDesc*) &TMP1078));
		lasterror_129528 = info;
	}
	break;
	case ((NU16) 220) ... ((NU16) 243):
	{
		NIM_BOOL LOC3;
		LOC3 = !(((goptions_105106 &(1<<((((NU8) 11))&31)))!=0));
		if (LOC3) goto LA4;
		LOC3 = !(((gnotes_128867 &(IL64(1)<<(((((NU16) (msg))- 220))&IL64(63))))!=0));
		LA4: ;
		ignoremsg = LOC3;
		{
			if (!!(ignoremsg)) goto LA7;
			writecontext_129416(info);
		}
		LA7: ;
		frmt = copyString(((NimStringDesc*) &TMP1079));
		gwarncounter_128870 += 1;
	}
	break;
	case ((NU16) 244) ... ((NU16) 259):
	{
		NIM_BOOL LOC10;
		LOC10 = !(((goptions_105106 &(1<<((((NU8) 12))&31)))!=0));
		if (LOC10) goto LA11;
		LOC10 = !(((gnotes_128867 &(IL64(1)<<(((((NU16) (msg))- 220))&IL64(63))))!=0));
		LA11: ;
		ignoremsg = LOC10;
		frmt = copyString(((NimStringDesc*) &TMP1080));
		ghintcounter_128869 += 1;
	}
	break;
	}
	memset((void*)LOC12, 0, sizeof(LOC12));
	LOC12[0] = tomsgfilename_129113(info);
	LOC12[1] = coordtostr_129280(((NI) (info.Line)));
	LOC12[2] = coordtostr_129280(((NI) (info.Col)));
	LOC12[3] = getmessagestr_129292(msg, arg);
	s = nsuFormatOpenArray(frmt, LOC12, 4);
	{
		if (!!(ignoremsg)) goto LA15;
		msgwriteln_129225(s);
		{
			NIM_BOOL LOC19;
			tslice129620 LOC21;
			LOC19 = (2 <= gverbosity_105116);
			if (!(LOC19)) goto LA20;
			LOC21 = HEX2EHEX2E_129610(((NU16) 0), ((NU16) 219));
			LOC19 = contains_129630(LOC21, msg);
			LA20: ;
			if (!LOC19) goto LA22;
			writesurroundingsrc_129530(info);
		}
		LA22: ;
	}
	LA15: ;
	handleerror_129339(msg, eh, s);
}

N_NIMCALL(void, localerror_129673)(tlineinfo128308 info, NU16 msg, NimStringDesc* arg) {
	limessage_129536(info, msg, arg, ((NU8) 0));
}

N_NIMCALL(void, message_129680)(tlineinfo128308 info, NU16 msg, NimStringDesc* arg) {
	limessage_129536(info, msg, arg, ((NU8) 0));
}

static N_INLINE(void, shallow_71620)(NimStringDesc** s_71623) {
	TGenericSeq* s;
	s = ((TGenericSeq*) ((*s_71623)));
	(*s).reserved = (NI)((*s).reserved | (IL64(-9223372036854775807) - IL64(1)));
}

N_NIMCALL(NI32, fileinfoidx_128506)(NimStringDesc* filename) {
	NI32 result;
	NimStringDesc* canon;
	NIM_BOOL pseudopath;
	TSafePoint TMP1297;
	result = 0;
	canon = 0;
	pseudopath = NIM_FALSE;
	pushSafePoint(&TMP1297);
	TMP1297.status = setjmp(TMP1297.context);
	if (TMP1297.status == 0) {
		canon = canonicalizepath_105315(filename);
		shallow_71620(&canon);
		popSafePoint();
	}
	else {
		popSafePoint();
		{
			TMP1297.status = 0;
			canon = copyString(filename);
			pseudopath = NIM_TRUE;
			popCurrentException();
		}
	}
	if (TMP1297.status != 0) reraiseException();
	{
		NIM_BOOL LOC6;
		LOC6 = haskey_128516(filenametoindextbl_128414, canon);
		if (!LOC6) goto LA7;
		result = HEX5BHEX5D_128555(filenametoindextbl_128414, canon);
	}
	goto LA4;
	LA7: ;
	{
		NimStringDesc* LOC10;
		tfileinfo128306 LOC16;
		NimStringDesc* LOC17;
		NimStringDesc* LOC18;
		result = ((NI32) (fileinfos_128435->Sup.len));
		LOC10 = 0;
		{
			if (!pseudopath) goto LA13;
			LOC10 = copyString(filename);
		}
		goto LA11;
		LA13: ;
		{
			LOC10 = shortendir_105403(canon);
		}
		LA11: ;
		memset((void*)&LOC16, 0, sizeof(LOC16));
		newfileinfo_128471(canon, LOC10, &LOC16);
		fileinfos_128435 = (TY128415*) incrSeq(&(fileinfos_128435)->Sup, sizeof(tfileinfo128306));
		LOC17 = 0;
		LOC17 = fileinfos_128435->data[fileinfos_128435->Sup.len-1].Fullpath; fileinfos_128435->data[fileinfos_128435->Sup.len-1].Fullpath = copyStringRC1(LOC16.Fullpath);
		if (LOC17) nimGCunrefNoCycle(LOC17);
		LOC18 = 0;
		LOC18 = fileinfos_128435->data[fileinfos_128435->Sup.len-1].Projpath; fileinfos_128435->data[fileinfos_128435->Sup.len-1].Projpath = copyStringRC1(LOC16.Projpath);
		if (LOC18) nimGCunrefNoCycle(LOC18);
		asgnRefNoCycle((void**) &fileinfos_128435->data[fileinfos_128435->Sup.len-1].Quotedname, LOC16.Quotedname);
		genericSeqAssign(&fileinfos_128435->data[fileinfos_128435->Sup.len-1].Lines, LOC16.Lines, (&NTI128316));
		HEX5BHEX5DHEX3D_128604(&filenametoindextbl_128414, canon, result);
	}
	LA4: ;
	return result;
}

N_NIMCALL(void, addcheckpoint_129180)(tlineinfo128308 info) {
	checkpoints_129174 = (TY128959*) incrSeq(&(checkpoints_129174)->Sup, sizeof(tlineinfo128308));
	checkpoints_129174->data[checkpoints_129174->Sup.len-1] = info;
}

N_NIMCALL(void, internalerror_129687)(tlineinfo128308 info, NimStringDesc* errmsg) {
	{
		if (!(gcmd_105110 == ((NU8) 14))) goto LA3;
		goto BeforeRet;
	}
	LA3: ;
	writecontext_129416(info);
	limessage_129536(info, ((NU16) 2), errmsg, ((NU8) 1));
	BeforeRet: ;
}

N_NIMCALL(NimStringDesc*, tofilename_129085)(NI32 fileidx) {
	NimStringDesc* result;
	result = 0;
	{
		if (!(fileidx < ((NI32) 0))) goto LA3;
		result = copyString(((NimStringDesc*) &TMP138));
	}
	goto LA1;
	LA3: ;
	{
		result = copyString(fileinfos_128435->data[fileidx].Projpath);
	}
	LA1: ;
	return result;
}

N_NIMCALL(void, fatal_129653)(tlineinfo128308 info, NU16 msg, NimStringDesc* arg) {
	limessage_129536(info, msg, arg, ((NU8) 1));
}

N_NIMCALL(NU8, incheckpoint_129309)(tlineinfo128308 current) {
	NU8 result;
	NI i_129321;
	NI HEX3Atmp_129326;
	NI res_129328;
	result = 0;
	i_129321 = 0;
	HEX3Atmp_129326 = 0;
	HEX3Atmp_129326 = (checkpoints_129174->Sup.len-1);
	res_129328 = 0;
	while (1) {
		if (!(res_129328 <= HEX3Atmp_129326)) goto LA1;
		i_129321 = res_129328;
		{
			if (!(current.Fileindex == checkpoints_129174->data[i_129321].Fileindex)) goto LA4;
			{
				NIM_BOOL LOC8;
				LOC8 = (current.Line == checkpoints_129174->data[i_129321].Line);
				if (!(LOC8)) goto LA9;
				LOC8 = ((NI16)abs((NI16)(current.Col - checkpoints_129174->data[i_129321].Col)) < ((NI16) 4));
				LA9: ;
				if (!LOC8) goto LA10;
				result = ((NU8) 2);
				goto BeforeRet;
			}
			LA10: ;
			{
				if (!(checkpoints_129174->data[i_129321].Line <= current.Line)) goto LA14;
				result = ((NU8) 1);
				goto BeforeRet;
			}
			LA14: ;
		}
		LA4: ;
		res_129328 += 1;
	} LA1: ;
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, suggestwriteln_128882)(NimStringDesc* s) {
	{
		if (!(gsilence_128872 == 0)) goto LA3;
		{
			TY129263 LOC9;
			if (!stdoutsocket_128873 == 0) goto LA7;
			memset((void*)LOC9, 0, sizeof(LOC9));
			LOC9[0] = copyString(s);
			writeln_105451(stdout, LOC9, 1);
		}
		goto LA5;
		LA7: ;
		{
			TY129263 LOC11;
			NimStringDesc* LOC12;
			memset((void*)LOC11, 0, sizeof(LOC11));
			LOC11[0] = copyString(s);
			writeln_105451(stdout, LOC11, 1);
			LOC12 = 0;
			LOC12 = rawNewString(s->Sup.len + 2);
appendString(LOC12, s);
appendString(LOC12, ((NimStringDesc*) &TMP1774));
			send_120404(stdoutsocket_128873, LOC12);
		}
		LA5: ;
	}
	LA3: ;
}

N_NIMCALL(void, globalerror_129660)(tlineinfo128308 info, NU16 msg, NimStringDesc* arg) {
	limessage_129536(info, msg, arg, ((NU8) 2));
}

N_NIMCALL(void, pushinfocontext_129012)(tlineinfo128308 info) {
	msgcontext_128979 = (TY128959*) incrSeq(&(msgcontext_128979)->Sup, sizeof(tlineinfo128308));
	msgcontext_128979->data[msgcontext_128979->Sup.len-1] = info;
}

N_NIMCALL(void, popinfocontext_129033)(void) {
	msgcontext_128979 = (TY128959*) setLengthSeq(&(msgcontext_128979)->Sup, sizeof(tlineinfo128308), (NI64)(msgcontext_128979->Sup.len - 1));
}
N_NIMCALL(void, TMP2429)(void* p, NI op) {
	esuggestdone128312* a;
	a = (esuggestdone128312*)p;
	nimGCvisit((void*)(*a).Sup.parent, op);
	nimGCvisit((void*)(*a).Sup.message, op);
	nimGCvisit((void*)(*a).Sup.trace, op);
}

N_NIMCALL(void, suggestquit_128921)(void) {
	{
		if (!!(isserving_105122)) goto LA3;
		exit(0);
	}
	goto LA1;
	LA3: ;
	{
		esuggestdone128312* e_128925;
		NimStringDesc* LOC8;
		if (!!((gdirtybufferidx_105123 == ((NI32) 0)))) goto LA6;
		e_128925 = 0;
		e_128925 = (esuggestdone128312*) newObj((&NTI128926), sizeof(esuggestdone128312));
		(*e_128925).Sup.Sup.m_type = (&NTI128312);
		LOC8 = 0;
		LOC8 = (*e_128925).Sup.message; (*e_128925).Sup.message = copyStringRC1(((NimStringDesc*) &TMP2430));
		if (LOC8) nimGCunrefNoCycle(LOC8);
		raiseException((E_Base*)e_128925, "ESuggestDone");
	}
	goto LA1;
	LA6: ;
	LA1: ;
}

N_NIMCALL(NI, getinfocontextlen_128982)(void) {
	NI result;
	result = 0;
	result = msgcontext_128979->Sup.len;
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, setinfocontextlen_128995)(NI l) {
	msgcontext_128979 = (TY128959*) setLengthSeq(&(msgcontext_128979)->Sup, sizeof(tlineinfo128308), l);
}

N_NIMCALL(tlineinfo128308, getinfocontext_129057)(NI index) {
	tlineinfo128308 result;
	NI l;
	NI i;
	memset((void*)&result, 0, sizeof(result));
	l = msgcontext_128979->Sup.len;
	{
		if (!(index < 0)) goto LA3;
		i = (NI64)(l + index);
	}
	goto LA1;
	LA3: ;
	{
		i = index;
	}
	LA1: ;
	{
		if (!((NU64)(l) <= (NU64)(i))) goto LA8;
		result = unknownlineinfo_128954();
	}
	goto LA6;
	LA8: ;
	{
		result = msgcontext_128979->data[i];
	}
	LA6: ;
	return result;
}

N_NIMCALL(trope126007*, quotedfilename_129813)(tlineinfo128308 i) {
	trope126007* result;
	result = 0;
	{
		NimStringDesc* LOC5;
		if (!!((((NI32) 0) <= i.Fileindex))) goto LA3;
		LOC5 = 0;
		LOC5 = HEX24_129777(TMP3123);
		internalerror_129699(LOC5);
	}
	LA3: ;
	result = fileinfos_128435->data[i.Fileindex].Quotedname;
	return result;
}

N_NIMCALL(void, globalerror_129667)(tlineinfo128308 info, NimStringDesc* arg) {
	limessage_129536(info, ((NU16) 4), arg, ((NU8) 2));
}

N_NIMCALL(void, outwriteln_129207)(NimStringDesc* s) {
	{
		TY129263 LOC5;
		if (!(gsilence_128872 == 0)) goto LA3;
		memset((void*)LOC5, 0, sizeof(LOC5));
		LOC5[0] = copyString(s);
		writeln_105451(stdout, LOC5, 1);
	}
	LA3: ;
}

N_NIMCALL(void, inittable_128325)(NI initialsize, ttable128335* Result) {
	(*Result).Counter = 0;
	unsureAsgnRef((void**) &(*Result).Data, (tkeyvaluepairseq128340*) newSeq((&NTI128340), initialsize));
}

static N_INLINE(void, writeln_105451)(FILE* f, NimStringDesc** x, NI xlen0) {
	NimStringDesc* i_105465;
	NI i_105471;
	i_105465 = 0;
	i_105471 = 0;
	while (1) {
		if (!(i_105471 < xlen0)) goto LA1;
		i_105465 = x[i_105471];
		write_9062(f, i_105465);
		i_105471 += 1;
	} LA1: ;
	write_9062(f, ((NimStringDesc*) &TMP4199));
}

static N_INLINE(NIM_BOOL, contains_129630)(tslice129620 s, NU16 value) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	result = 0;
	LOC1 = (s.A <= value);
	if (!(LOC1)) goto LA2;
	LOC1 = (value <= s.B);
	LA2: ;
	result = LOC1;
	return result;
}

static N_INLINE(tslice129620, HEX2EHEX2E_129610)(NU16 a, NU16 b) {
	tslice129620 result;
	memset((void*)&result, 0, sizeof(result));
	result.A = a;
	result.B = b;
	return result;
}

N_NIMCALL(NimStringDesc*, HEX24_129777)(TY71082 x) {
	NimStringDesc* result;
	result = 0;
	result = copyString(((NimStringDesc*) &TMP4200));
	while (1) {
		NimStringDesc* LOC10;
		{
			if (!(1 < result->Sup.len)) goto LA4;
			result = resizeString(result, 2);
appendString(result, ((NimStringDesc*) &TMP4201));
		}
		LA4: ;
		result = resizeString(result, 8);
appendString(result, ((NimStringDesc*) &TMP4202));
		result = resizeString(result, 2);
appendString(result, ((NimStringDesc*) &TMP4203));
		result = resizeString(result, x.Field0->Sup.len + 0);
appendString(result, x.Field0);
		{
			if (!(1 < result->Sup.len)) goto LA8;
			result = resizeString(result, 2);
appendString(result, ((NimStringDesc*) &TMP4201));
		}
		LA8: ;
		result = resizeString(result, 4);
appendString(result, ((NimStringDesc*) &TMP4204));
		result = resizeString(result, 2);
appendString(result, ((NimStringDesc*) &TMP4203));
		LOC10 = 0;
		LOC10 = nimIntToStr(x.Field1);
		result = resizeString(result, LOC10->Sup.len + 0);
appendString(result, LOC10);
		goto LA1;
	} LA1: ;
	result = resizeString(result, 1);
appendString(result, ((NimStringDesc*) &TMP4205));
	return result;
}

N_NIMCALL(NIM_BOOL, haskey_128516)(ttable128335 t, NimStringDesc* key) {
	NIM_BOOL result;
	NI LOC1;
	result = 0;
	LOC1 = rawget_128527(t, key);
	result = (0 <= LOC1);
	return result;
}

N_NIMCALL(NI32, HEX5BHEX5D_128555)(ttable128335 t, NimStringDesc* key) {
	NI32 result;
	NI index;
	result = 0;
	index = rawget_128527(t, key);
	{
		if (!(0 <= index)) goto LA3;
		result = t.Data->data[index].Field2;
	}
	LA3: ;
	return result;
}

static N_INLINE(NIM_BOOL, mustrehash_108283)(NI length, NI counter) {
	NIM_BOOL result;
	NIM_BOOL LOC1;
	result = 0;
	LOC1 = ((NI64)(length * 2) < (NI64)(counter * 3));
	if (LOC1) goto LA2;
	LOC1 = ((NI64)(length - counter) < 4);
	LA2: ;
	result = LOC1;
	return result;
}

N_NIMCALL(void, HEX5BHEX5DHEX3D_128604)(ttable128335* t, NimStringDesc* key, NI32 val) {
	NI index;
	index = rawget_128527((*t), key);
	{
		if (!(0 <= index)) goto LA3;
		(*t).Data->data[index].Field2 = val;
	}
	goto LA1;
	LA3: ;
	{
		{
			NIM_BOOL LOC8;
			LOC8 = mustrehash_108283((*t).Data->Sup.len, (*t).Counter);
			if (!LOC8) goto LA9;
			enlarge_128637(t);
		}
		LA9: ;
		rawinsert_128690(t, &(*t).Data, key, val);
		(*t).Counter += 1;
	}
	LA1: ;
}

static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b) {
	NIM_BOOL result;
	NIM_BOOL LOC11;
	int LOC13;
	result = 0;
	{
		if (!(a == b)) goto LA3;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		LOC7 = (a == NIM_NIL);
		if (LOC7) goto LA8;
		LOC7 = (b == NIM_NIL);
		LA8: ;
		if (!LOC7) goto LA9;
		result = NIM_FALSE;
		goto BeforeRet;
	}
	LA9: ;
	LOC11 = ((*a).Sup.len == (*b).Sup.len);
	if (!(LOC11)) goto LA12;
	LOC13 = memcmp(((NCSTRING) ((*a).data)), ((NCSTRING) ((*b).data)), (NI64)((*a).Sup.len * 1));
	LOC11 = (LOC13 == ((NI32) 0));
	LA12: ;
	result = LOC11;
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

static N_INLINE(NI, nexttry_108407)(NI h, NI maxhash) {
	NI result;
	result = 0;
	result = (NI)((NI64)((NI64)(5 * h) + 1) & maxhash);
	return result;
}

N_NIMCALL(NI, rawget_128527)(ttable128335 t, NimStringDesc* key) {
	NI result;
	NI h;
	NI LOC1;
	result = 0;
	LOC1 = hash_101825(key);
	h = (NI)(LOC1 & (t.Data->Sup.len-1));
	while (1) {
		if (!!((t.Data->data[h].Field0 == ((NU8) 0)))) goto LA2;
		{
			NIM_BOOL LOC5;
			LOC5 = eqStrings(t.Data->data[h].Field1, key);
			if (!(LOC5)) goto LA6;
			LOC5 = (t.Data->data[h].Field0 == ((NU8) 1));
			LA6: ;
			if (!LOC5) goto LA7;
			result = h;
			goto BeforeRet;
		}
		LA7: ;
		h = nexttry_108407(h, (t.Data->Sup.len-1));
	} LA2: ;
	result = -1;
	BeforeRet: ;
	return result;
}

N_NIMCALL(void, enlarge_128637)(ttable128335* t) {
	tkeyvaluepairseq128340* n;
	NI i_128674;
	NI HEX3Atmp_128723;
	NI res_128725;
	tkeyvaluepairseq128340* LOC6;
	n = 0;
	n = (tkeyvaluepairseq128340*) newSeq((&NTI128340), (NI64)((*t).Data->Sup.len * 2));
	i_128674 = 0;
	HEX3Atmp_128723 = 0;
	HEX3Atmp_128723 = ((*t).Data->Sup.len-1);
	res_128725 = 0;
	while (1) {
		if (!(res_128725 <= HEX3Atmp_128723)) goto LA1;
		i_128674 = res_128725;
		{
			if (!((*t).Data->data[i_128674].Field0 == ((NU8) 1))) goto LA4;
			rawinsert_128690(t, &n, (*t).Data->data[i_128674].Field1, (*t).Data->data[i_128674].Field2);
		}
		LA4: ;
		res_128725 += 1;
	} LA1: ;
	LOC6 = 0;
	LOC6 = (*t).Data;
	unsureAsgnRef((void**) &(*t).Data, n);
	n = LOC6;
}

N_NIMCALL(void, rawinsert_128690)(ttable128335* t, tkeyvaluepairseq128340** data, NimStringDesc* key, NI32 val) {
	NI h;
	NI LOC1;
	NimStringDesc* LOC3;
	LOC1 = hash_101825(key);
	h = (NI)(LOC1 & ((*data)->Sup.len-1));
	while (1) {
		if (!((*data)->data[h].Field0 == ((NU8) 1))) goto LA2;
		h = nexttry_108407(h, ((*data)->Sup.len-1));
	} LA2: ;
	LOC3 = 0;
	LOC3 = (*data)->data[h].Field1; (*data)->data[h].Field1 = copyStringRC1(key);
	if (LOC3) nimGCunrefNoCycle(LOC3);
	(*data)->data[h].Field2 = val;
	(*data)->data[h].Field0 = ((NU8) 1);
}
N_NOINLINE(void, msgsInit)(void) {
	tfileinfo128306 LOC1;
	NimStringDesc* LOC2;
	NimStringDesc* LOC3;
	tfileinfo128306 LOC4;
	NimStringDesc* LOC5;
	NimStringDesc* LOC6;
	TY126103 LOC7;
	chckNil((void*)&filenametoindextbl_128414);
	genericReset((void*)&filenametoindextbl_128414, (&NTI128335));
	inittable_128325(64, &filenametoindextbl_128414);
	if (fileinfos_128435) nimGCunrefNoCycle(fileinfos_128435);
	fileinfos_128435 = (TY128415*) newSeqRC1((&NTI128415), 0);
	memset((void*)&LOC1, 0, sizeof(LOC1));
	newfileinfo_128471(((NimStringDesc*) &TMP131), ((NimStringDesc*) &TMP132), &LOC1);
	fileinfos_128435 = (TY128415*) incrSeq(&(fileinfos_128435)->Sup, sizeof(tfileinfo128306));
	LOC2 = 0;
	LOC2 = fileinfos_128435->data[fileinfos_128435->Sup.len-1].Fullpath; fileinfos_128435->data[fileinfos_128435->Sup.len-1].Fullpath = copyStringRC1(LOC1.Fullpath);
	if (LOC2) nimGCunrefNoCycle(LOC2);
	LOC3 = 0;
	LOC3 = fileinfos_128435->data[fileinfos_128435->Sup.len-1].Projpath; fileinfos_128435->data[fileinfos_128435->Sup.len-1].Projpath = copyStringRC1(LOC1.Projpath);
	if (LOC3) nimGCunrefNoCycle(LOC3);
	asgnRefNoCycle((void**) &fileinfos_128435->data[fileinfos_128435->Sup.len-1].Quotedname, LOC1.Quotedname);
	genericSeqAssign(&fileinfos_128435->data[fileinfos_128435->Sup.len-1].Lines, LOC1.Lines, (&NTI128316));
	gcmdlineinfo_128801 = newlineinfo_128768(((NI32) 0), 1, 1);
	memset((void*)&LOC4, 0, sizeof(LOC4));
	newfileinfo_128471(((NimStringDesc*) &TMP131), ((NimStringDesc*) &TMP133), &LOC4);
	fileinfos_128435 = (TY128415*) incrSeq(&(fileinfos_128435)->Sup, sizeof(tfileinfo128306));
	LOC5 = 0;
	LOC5 = fileinfos_128435->data[fileinfos_128435->Sup.len-1].Fullpath; fileinfos_128435->data[fileinfos_128435->Sup.len-1].Fullpath = copyStringRC1(LOC4.Fullpath);
	if (LOC5) nimGCunrefNoCycle(LOC5);
	LOC6 = 0;
	LOC6 = fileinfos_128435->data[fileinfos_128435->Sup.len-1].Projpath; fileinfos_128435->data[fileinfos_128435->Sup.len-1].Projpath = copyStringRC1(LOC4.Projpath);
	if (LOC6) nimGCunrefNoCycle(LOC6);
	asgnRefNoCycle((void**) &fileinfos_128435->data[fileinfos_128435->Sup.len-1].Quotedname, LOC4.Quotedname);
	genericSeqAssign(&fileinfos_128435->data[fileinfos_128435->Sup.len-1].Lines, LOC4.Lines, (&NTI128316));
	gcodegenlineinfo_128820 = newlineinfo_128768(((NI32) 1), 1, 1);
	gnotes_128867 = IL64(1099504025599);
	gerrorcounter_128868 = 0;
	ghintcounter_128869 = 0;
	gwarncounter_128870 = 0;
	gerrormax_128871 = 1;
	if (msgcontext_128979) nimGCunrefNoCycle(msgcontext_128979);
	msgcontext_128979 = (TY128959*) newSeqRC1((&NTI128959), 0);
	if (checkpoints_129174) nimGCunrefNoCycle(checkpoints_129174);
	checkpoints_129174 = (TY128959*) newSeqRC1((&NTI128959), 0);
	lasterror_129528 = unknownlineinfo_128954();
	memset((void*)&LOC7, 0, sizeof(LOC7));
	LOC7.ClPrc = ((TMP402) (HEX3Aanonymous_129824)); LOC7.ClEnv = NIM_NIL;
	asgnRef((void**) &errorhandler_126108.ClEnv, LOC7.ClEnv);
	errorhandler_126108.ClPrc = LOC7.ClPrc;
}

N_NOINLINE(void, msgsDatInit)(void) {
static TNimNode* TMP126[4];
static TNimNode* TMP134[3];
static TNimNode* TMP1768[260];
NI TMP1770;
static char* NIM_CONST TMP1769[260] = {
"errUnknown", 
"errIllFormedAstX", 
"errInternal", 
"errCannotOpenFile", 
"errGenerated", 
"errXCompilerDoesNotSupportCpp", 
"errStringLiteralExpected", 
"errIntLiteralExpected", 
"errInvalidCharacterConstant", 
"errClosingTripleQuoteExpected", 
"errClosingQuoteExpected", 
"errTabulatorsAreNotAllowed", 
"errInvalidToken", 
"errLineTooLong", 
"errInvalidNumber", 
"errNumberOutOfRange", 
"errNnotAllowedInCharacter", 
"errClosingBracketExpected", 
"errMissingFinalQuote", 
"errIdentifierExpected", 
"errNewlineExpected", 
"errInvalidModuleName", 
"errOperatorExpected", 
"errTokenExpected", 
"errStringAfterIncludeExpected", 
"errRecursiveDependencyX", 
"errOnOrOffExpected", 
"errNoneSpeedOrSizeExpected", 
"errInvalidPragma", 
"errUnknownPragma", 
"errInvalidDirectiveX", 
"errAtPopWithoutPush", 
"errEmptyAsm", 
"errInvalidIndentation", 
"errExceptionExpected", 
"errExceptionAlreadyHandled", 
"errYieldNotAllowedHere", 
"errYieldNotAllowedInTryStmt", 
"errInvalidNumberOfYieldExpr", 
"errCannotReturnExpr", 
"errAttemptToRedefine", 
"errStmtInvalidAfterReturn", 
"errStmtExpected", 
"errInvalidLabel", 
"errInvalidCmdLineOption", 
"errCmdLineArgExpected", 
"errCmdLineNoArgExpected", 
"errInvalidVarSubstitution", 
"errUnknownVar", 
"errUnknownCcompiler", 
"errOnOrOffExpectedButXFound", 
"errNoneBoehmRefcExpectedButXFound", 
"errNoneSpeedOrSizeExpectedButXFound", 
"errGuiConsoleOrLibExpectedButXFound", 
"errUnknownOS", 
"errUnknownCPU", 
"errGenOutExpectedButXFound", 
"errArgsNeedRunOption", 
"errInvalidMultipleAsgn", 
"errColonOrEqualsExpected", 
"errExprExpected", 
"errUndeclaredIdentifier", 
"errUseQualifier", 
"errTypeExpected", 
"errSystemNeeds", 
"errExecutionOfProgramFailed", 
"errNotOverloadable", 
"errInvalidArgForX", 
"errStmtHasNoEffect", 
"errXExpectsTypeOrValue", 
"errXExpectsArrayType", 
"errIteratorCannotBeInstantiated", 
"errExprXAmbiguous", 
"errConstantDivisionByZero", 
"errOrdinalTypeExpected", 
"errOrdinalOrFloatTypeExpected", 
"errOverOrUnderflow", 
"errCannotEvalXBecauseIncompletelyDefined", 
"errChrExpectsRange0_255", 
"errDynlibRequiresExportc", 
"errUndeclaredFieldX", 
"errNilAccess", 
"errIndexOutOfBounds", 
"errIndexTypesDoNotMatch", 
"errBracketsInvalidForType", 
"errValueOutOfSetBounds", 
"errFieldInitTwice", 
"errFieldNotInit", 
"errExprXCannotBeCalled", 
"errExprHasNoType", 
"errExprXHasNoType", 
"errCastNotInSafeMode", 
"errExprCannotBeCastedToX", 
"errCommaOrParRiExpected", 
"errCurlyLeOrParLeExpected", 
"errSectionExpected", 
"errRangeExpected", 
"errMagicOnlyInSystem", 
"errPowerOfTwoExpected", 
"errStringMayNotBeEmpty", 
"errCallConvExpected", 
"errProcOnlyOneCallConv", 
"errSymbolMustBeImported", 
"errExprMustBeBool", 
"errConstExprExpected", 
"errDuplicateCaseLabel", 
"errRangeIsEmpty", 
"errSelectorMustBeOfCertainTypes", 
"errSelectorMustBeOrdinal", 
"errOrdXMustNotBeNegative", 
"errLenXinvalid", 
"errWrongNumberOfVariables", 
"errExprCannotBeRaised", 
"errBreakOnlyInLoop", 
"errTypeXhasUnknownSize", 
"errConstNeedsConstExpr", 
"errConstNeedsValue", 
"errResultCannotBeOpenArray", 
"errSizeTooBig", 
"errSetTooBig", 
"errBaseTypeMustBeOrdinal", 
"errInheritanceOnlyWithNonFinalObjects", 
"errInheritanceOnlyWithEnums", 
"errIllegalRecursionInTypeX", 
"errCannotInstantiateX", 
"errExprHasNoAddress", 
"errXStackEscape", 
"errVarForOutParamNeeded", 
"errPureTypeMismatch", 
"errTypeMismatch", 
"errButExpected", 
"errButExpectedX", 
"errAmbiguousCallXYZ", 
"errWrongNumberOfArguments", 
"errXCannotBePassedToProcVar", 
"errXCannotBeInParamDecl", 
"errPragmaOnlyInHeaderOfProc", 
"errImplOfXNotAllowed", 
"errImplOfXexpected", 
"errNoSymbolToBorrowFromFound", 
"errDiscardValue", 
"errInvalidDiscard", 
"errIllegalConvFromXtoY", 
"errCannotBindXTwice", 
"errInvalidOrderInArrayConstructor", 
"errInvalidOrderInEnumX", 
"errEnumXHasHoles", 
"errExceptExpected", 
"errInvalidTry", 
"errOptionExpected", 
"errXisNoLabel", 
"errNotAllCasesCovered", 
"errUnkownSubstitionVar", 
"errComplexStmtRequiresInd", 
"errXisNotCallable", 
"errNoPragmasAllowedForX", 
"errNoGenericParamsAllowedForX", 
"errInvalidParamKindX", 
"errDefaultArgumentInvalid", 
"errNamedParamHasToBeIdent", 
"errNoReturnTypeForX", 
"errConvNeedsOneArg", 
"errInvalidPragmaX", 
"errXNotAllowedHere", 
"errInvalidControlFlowX", 
"errXisNoType", 
"errCircumNeedsPointer", 
"errInvalidExpression", 
"errInvalidExpressionX", 
"errEnumHasNoValueX", 
"errNamedExprExpected", 
"errNamedExprNotAllowed", 
"errXExpectsOneTypeParam", 
"errArrayExpectsTwoTypeParams", 
"errInvalidVisibilityX", 
"errInitHereNotAllowed", 
"errXCannotBeAssignedTo", 
"errIteratorNotAllowed", 
"errXNeedsReturnType", 
"errNoReturnTypeDeclared", 
"errInvalidCommandX", 
"errXOnlyAtModuleScope", 
"errXNeedsParamObjectType", 
"errTemplateInstantiationTooNested", 
"errInstantiationFrom", 
"errInvalidIndexValueForTuple", 
"errCommandExpectsFilename", 
"errMainModuleMustBeSpecified", 
"errXExpected", 
"errInvalidSectionStart", 
"errGridTableNotImplemented", 
"errGeneralParseError", 
"errNewSectionExpected", 
"errWhitespaceExpected", 
"errXisNoValidIndexFile", 
"errCannotRenderX", 
"errVarVarTypeNotAllowed", 
"errInstantiateXExplicitely", 
"errXExpectsTwoArguments", 
"errXExpectsObjectTypes", 
"errXcanNeverBeOfThisSubtype", 
"errTooManyIterations", 
"errCannotInterpretNodeX", 
"errFieldXNotFound", 
"errInvalidConversionFromTypeX", 
"errAssertionFailed", 
"errCannotGenerateCodeForX", 
"errXRequiresOneArgument", 
"errUnhandledExceptionX", 
"errCyclicTree", 
"errXisNoMacroOrTemplate", 
"errXhasSideEffects", 
"errIteratorExpected", 
"errLetNeedsInit", 
"errThreadvarCannotInit", 
"errWrongSymbolX", 
"errIllegalCaptureX", 
"errXCannotBeClosure", 
"errXMustBeCompileTime", 
"errUser", 
"warnCannotOpenFile", 
"warnOctalEscape", 
"warnXIsNeverRead", 
"warnXmightNotBeenInit", 
"warnDeprecated", 
"warnConfigDeprecated", 
"warnSmallLshouldNotBeUsed", 
"warnUnknownMagic", 
"warnRedefinitionOfLabel", 
"warnUnknownSubstitutionX", 
"warnLanguageXNotSupported", 
"warnCommentXIgnored", 
"warnNilStatement", 
"warnAnalysisLoophole", 
"warnDifferentHeaps", 
"warnWriteToForeignHeap", 
"warnImplicitClosure", 
"warnEachIdentIsTuple", 
"warnShadowIdent", 
"warnProveInit", 
"warnProveField", 
"warnProveIndex", 
"warnUninit", 
"warnUser", 
"hintSuccess", 
"hintSuccessX", 
"hintLineTooLong", 
"hintXDeclaredButNotUsed", 
"hintConvToBaseNotNeeded", 
"hintConvFromXtoItselfNotNeeded", 
"hintExprAlwaysX", 
"hintQuitCalled", 
"hintProcessing", 
"hintCodeBegin", 
"hintCodeEnd", 
"hintConf", 
"hintPath", 
"hintConditionAlwaystrue", 
"hintPattern", 
"hintUser"};
static TNimNode TMP17[273];
NTI128306.size = sizeof(tfileinfo128306);
NTI128306.kind = 18;
NTI128306.base = 0;
NTI128306.flags = 2;
TMP126[0] = &TMP17[1];
TMP17[1].kind = 1;
TMP17[1].offset = offsetof(tfileinfo128306, Fullpath);
TMP17[1].typ = (&NTI143);
TMP17[1].name = "fullPath";
TMP126[1] = &TMP17[2];
TMP17[2].kind = 1;
TMP17[2].offset = offsetof(tfileinfo128306, Projpath);
TMP17[2].typ = (&NTI143);
TMP17[2].name = "projPath";
TMP126[2] = &TMP17[3];
TMP17[3].kind = 1;
TMP17[3].offset = offsetof(tfileinfo128306, Quotedname);
TMP17[3].typ = (&NTI126005);
TMP17[3].name = "quotedName";
TMP126[3] = &TMP17[4];
NTI128316.size = sizeof(TY128316*);
NTI128316.kind = 24;
NTI128316.base = (&NTI126005);
NTI128316.flags = 2;
NTI128316.marker = TMP127;
TMP17[4].kind = 1;
TMP17[4].offset = offsetof(tfileinfo128306, Lines);
TMP17[4].typ = (&NTI128316);
TMP17[4].name = "lines";
TMP17[0].len = 4; TMP17[0].kind = 2; TMP17[0].sons = &TMP126[0];
NTI128306.node = &TMP17[0];
NTI128415.size = sizeof(TY128415*);
NTI128415.kind = 24;
NTI128415.base = (&NTI128306);
NTI128415.flags = 2;
NTI128415.marker = TMP128;
NTI128308.size = sizeof(tlineinfo128308);
NTI128308.kind = 18;
NTI128308.base = 0;
NTI128308.flags = 3;
TMP134[0] = &TMP17[6];
TMP17[6].kind = 1;
TMP17[6].offset = offsetof(tlineinfo128308, Line);
TMP17[6].typ = (&NTI109);
TMP17[6].name = "line";
TMP134[1] = &TMP17[7];
TMP17[7].kind = 1;
TMP17[7].offset = offsetof(tlineinfo128308, Col);
TMP17[7].typ = (&NTI109);
TMP17[7].name = "col";
TMP134[2] = &TMP17[8];
TMP17[8].kind = 1;
TMP17[8].offset = offsetof(tlineinfo128308, Fileindex);
TMP17[8].typ = (&NTI111);
TMP17[8].name = "fileIndex";
TMP17[5].len = 3; TMP17[5].kind = 2; TMP17[5].sons = &TMP134[0];
NTI128308.node = &TMP17[5];
NTI128959.size = sizeof(TY128959*);
NTI128959.kind = 24;
NTI128959.base = (&NTI128308);
NTI128959.flags = 2;
NTI128959.marker = TMP135;
NTI128310.size = sizeof(erecoverableerror128310);
NTI128310.kind = 17;
NTI128310.base = (&NTI1053);
NTI128310.flags = 2;
TMP17[9].len = 0; TMP17[9].kind = 2;
NTI128310.node = &TMP17[9];
NTI128828.size = sizeof(erecoverableerror128310*);
NTI128828.kind = 22;
NTI128828.base = (&NTI128310);
NTI128828.flags = 2;
NTI128828.marker = TMP399;
NTI128003.size = sizeof(NU16);
NTI128003.kind = 14;
NTI128003.base = 0;
NTI128003.flags = 3;
for (TMP1770 = 0; TMP1770 < 260; TMP1770++) {
TMP17[TMP1770+10].kind = 1;
TMP17[TMP1770+10].offset = TMP1770;
TMP17[TMP1770+10].name = TMP1769[TMP1770];
TMP1768[TMP1770] = &TMP17[TMP1770+10];
}
TMP17[270].len = 260; TMP17[270].kind = 2; TMP17[270].sons = &TMP1768[0];
NTI128003.node = &TMP17[270];
NTI128302.size = sizeof(NU16);
NTI128302.kind = 20;
NTI128302.base = (&NTI128003);
NTI128302.flags = 3;
NTI128304.size = sizeof(NU64);
NTI128304.kind = 19;
NTI128304.base = (&NTI128302);
NTI128304.flags = 3;
TMP17[271].len = 220; TMP17[271].kind = 0;
NTI128304.node = &TMP17[271];
NTI128312.size = sizeof(esuggestdone128312);
NTI128312.kind = 17;
NTI128312.base = (&NTI1025);
NTI128312.flags = 2;
TMP17[272].len = 0; TMP17[272].kind = 2;
NTI128312.node = &TMP17[272];
NTI128926.size = sizeof(esuggestdone128312*);
NTI128926.kind = 22;
NTI128926.base = (&NTI128312);
NTI128926.flags = 2;
NTI128926.marker = TMP2429;
}

